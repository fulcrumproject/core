// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
	"context"
	"time"

	"github.com/fulcrumproject/core/pkg/auth"
	"github.com/fulcrumproject/core/pkg/properties"
	mock "github.com/stretchr/testify/mock"
)

// NewMockAgentCommander creates a new instance of MockAgentCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAgentCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAgentCommander {
	mock := &MockAgentCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAgentCommander is an autogenerated mock type for the AgentCommander type
type MockAgentCommander struct {
	mock.Mock
}

type MockAgentCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAgentCommander) EXPECT() *MockAgentCommander_Expecter {
	return &MockAgentCommander_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockAgentCommander
func (_mock *MockAgentCommander) Create(ctx context.Context, name string, providerID properties.UUID, agentTypeID properties.UUID, tags []string) (*Agent, error) {
	ret := _mock.Called(ctx, name, providerID, agentTypeID, tags)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, properties.UUID, properties.UUID, []string) (*Agent, error)); ok {
		return returnFunc(ctx, name, providerID, agentTypeID, tags)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, properties.UUID, properties.UUID, []string) *Agent); ok {
		r0 = returnFunc(ctx, name, providerID, agentTypeID, tags)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, properties.UUID, properties.UUID, []string) error); ok {
		r1 = returnFunc(ctx, name, providerID, agentTypeID, tags)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentCommander_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockAgentCommander_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - providerID properties.UUID
//   - agentTypeID properties.UUID
//   - tags []string
func (_e *MockAgentCommander_Expecter) Create(ctx interface{}, name interface{}, providerID interface{}, agentTypeID interface{}, tags interface{}) *MockAgentCommander_Create_Call {
	return &MockAgentCommander_Create_Call{Call: _e.mock.On("Create", ctx, name, providerID, agentTypeID, tags)}
}

func (_c *MockAgentCommander_Create_Call) Run(run func(ctx context.Context, name string, providerID properties.UUID, agentTypeID properties.UUID, tags []string)) *MockAgentCommander_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 properties.UUID
		if args[2] != nil {
			arg2 = args[2].(properties.UUID)
		}
		var arg3 properties.UUID
		if args[3] != nil {
			arg3 = args[3].(properties.UUID)
		}
		var arg4 []string
		if args[4] != nil {
			arg4 = args[4].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockAgentCommander_Create_Call) Return(agent *Agent, err error) *MockAgentCommander_Create_Call {
	_c.Call.Return(agent, err)
	return _c
}

func (_c *MockAgentCommander_Create_Call) RunAndReturn(run func(ctx context.Context, name string, providerID properties.UUID, agentTypeID properties.UUID, tags []string) (*Agent, error)) *MockAgentCommander_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockAgentCommander
func (_mock *MockAgentCommander) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAgentCommander_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockAgentCommander_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentCommander_Expecter) Delete(ctx interface{}, id interface{}) *MockAgentCommander_Delete_Call {
	return &MockAgentCommander_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockAgentCommander_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentCommander_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentCommander_Delete_Call) Return(err error) *MockAgentCommander_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAgentCommander_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockAgentCommander_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockAgentCommander
func (_mock *MockAgentCommander) Update(ctx context.Context, id properties.UUID, name *string, status *AgentStatus, tags *[]string) (*Agent, error) {
	ret := _mock.Called(ctx, id, name, status, tags)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string, *AgentStatus, *[]string) (*Agent, error)); ok {
		return returnFunc(ctx, id, name, status, tags)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string, *AgentStatus, *[]string) *Agent); ok {
		r0 = returnFunc(ctx, id, name, status, tags)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, *string, *AgentStatus, *[]string) error); ok {
		r1 = returnFunc(ctx, id, name, status, tags)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentCommander_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockAgentCommander_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
//   - name *string
//   - status *AgentStatus
//   - tags *[]string
func (_e *MockAgentCommander_Expecter) Update(ctx interface{}, id interface{}, name interface{}, status interface{}, tags interface{}) *MockAgentCommander_Update_Call {
	return &MockAgentCommander_Update_Call{Call: _e.mock.On("Update", ctx, id, name, status, tags)}
}

func (_c *MockAgentCommander_Update_Call) Run(run func(ctx context.Context, id properties.UUID, name *string, status *AgentStatus, tags *[]string)) *MockAgentCommander_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		var arg3 *AgentStatus
		if args[3] != nil {
			arg3 = args[3].(*AgentStatus)
		}
		var arg4 *[]string
		if args[4] != nil {
			arg4 = args[4].(*[]string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockAgentCommander_Update_Call) Return(agent *Agent, err error) *MockAgentCommander_Update_Call {
	_c.Call.Return(agent, err)
	return _c
}

func (_c *MockAgentCommander_Update_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID, name *string, status *AgentStatus, tags *[]string) (*Agent, error)) *MockAgentCommander_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStatus provides a mock function for the type MockAgentCommander
func (_mock *MockAgentCommander) UpdateStatus(ctx context.Context, id properties.UUID, status AgentStatus) (*Agent, error) {
	ret := _mock.Called(ctx, id, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStatus")
	}

	var r0 *Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, AgentStatus) (*Agent, error)); ok {
		return returnFunc(ctx, id, status)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, AgentStatus) *Agent); ok {
		r0 = returnFunc(ctx, id, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, AgentStatus) error); ok {
		r1 = returnFunc(ctx, id, status)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentCommander_UpdateStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStatus'
type MockAgentCommander_UpdateStatus_Call struct {
	*mock.Call
}

// UpdateStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
//   - status AgentStatus
func (_e *MockAgentCommander_Expecter) UpdateStatus(ctx interface{}, id interface{}, status interface{}) *MockAgentCommander_UpdateStatus_Call {
	return &MockAgentCommander_UpdateStatus_Call{Call: _e.mock.On("UpdateStatus", ctx, id, status)}
}

func (_c *MockAgentCommander_UpdateStatus_Call) Run(run func(ctx context.Context, id properties.UUID, status AgentStatus)) *MockAgentCommander_UpdateStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 AgentStatus
		if args[2] != nil {
			arg2 = args[2].(AgentStatus)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAgentCommander_UpdateStatus_Call) Return(agent *Agent, err error) *MockAgentCommander_UpdateStatus_Call {
	_c.Call.Return(agent, err)
	return _c
}

func (_c *MockAgentCommander_UpdateStatus_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID, status AgentStatus) (*Agent, error)) *MockAgentCommander_UpdateStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAgentRepository creates a new instance of MockAgentRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAgentRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAgentRepository {
	mock := &MockAgentRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAgentRepository is an autogenerated mock type for the AgentRepository type
type MockAgentRepository struct {
	mock.Mock
}

type MockAgentRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAgentRepository) EXPECT() *MockAgentRepository_Expecter {
	return &MockAgentRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockAgentRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockAgentRepository_AuthScope_Call {
	return &MockAgentRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockAgentRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockAgentRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockAgentRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockAgentRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockAgentRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAgentRepository_Expecter) Count(ctx interface{}) *MockAgentRepository_Count_Call {
	return &MockAgentRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockAgentRepository_Count_Call) Run(run func(ctx context.Context)) *MockAgentRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAgentRepository_Count_Call) Return(n int64, err error) *MockAgentRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAgentRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockAgentRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CountByProvider provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) CountByProvider(ctx context.Context, providerID properties.UUID) (int64, error) {
	ret := _mock.Called(ctx, providerID)

	if len(ret) == 0 {
		panic("no return value specified for CountByProvider")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (int64, error)); ok {
		return returnFunc(ctx, providerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) int64); ok {
		r0 = returnFunc(ctx, providerID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, providerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentRepository_CountByProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByProvider'
type MockAgentRepository_CountByProvider_Call struct {
	*mock.Call
}

// CountByProvider is a helper method to define mock.On call
//   - ctx context.Context
//   - providerID properties.UUID
func (_e *MockAgentRepository_Expecter) CountByProvider(ctx interface{}, providerID interface{}) *MockAgentRepository_CountByProvider_Call {
	return &MockAgentRepository_CountByProvider_Call{Call: _e.mock.On("CountByProvider", ctx, providerID)}
}

func (_c *MockAgentRepository_CountByProvider_Call) Run(run func(ctx context.Context, providerID properties.UUID)) *MockAgentRepository_CountByProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentRepository_CountByProvider_Call) Return(n int64, err error) *MockAgentRepository_CountByProvider_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAgentRepository_CountByProvider_Call) RunAndReturn(run func(ctx context.Context, providerID properties.UUID) (int64, error)) *MockAgentRepository_CountByProvider_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) Create(ctx context.Context, entity *Agent) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Agent) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAgentRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockAgentRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Agent
func (_e *MockAgentRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockAgentRepository_Create_Call {
	return &MockAgentRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockAgentRepository_Create_Call) Run(run func(ctx context.Context, entity *Agent)) *MockAgentRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Agent
		if args[1] != nil {
			arg1 = args[1].(*Agent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentRepository_Create_Call) Return(err error) *MockAgentRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAgentRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *Agent) error) *MockAgentRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAgentRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockAgentRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockAgentRepository_Delete_Call {
	return &MockAgentRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockAgentRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentRepository_Delete_Call) Return(err error) *MockAgentRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAgentRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockAgentRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockAgentRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockAgentRepository_Exists_Call {
	return &MockAgentRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockAgentRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentRepository_Exists_Call) Return(b bool, err error) *MockAgentRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockAgentRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockAgentRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FindByServiceTypeAndTags provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) FindByServiceTypeAndTags(ctx context.Context, serviceTypeID properties.UUID, tags []string) ([]*Agent, error) {
	ret := _mock.Called(ctx, serviceTypeID, tags)

	if len(ret) == 0 {
		panic("no return value specified for FindByServiceTypeAndTags")
	}

	var r0 []*Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, []string) ([]*Agent, error)); ok {
		return returnFunc(ctx, serviceTypeID, tags)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, []string) []*Agent); ok {
		r0 = returnFunc(ctx, serviceTypeID, tags)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, []string) error); ok {
		r1 = returnFunc(ctx, serviceTypeID, tags)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentRepository_FindByServiceTypeAndTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByServiceTypeAndTags'
type MockAgentRepository_FindByServiceTypeAndTags_Call struct {
	*mock.Call
}

// FindByServiceTypeAndTags is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceTypeID properties.UUID
//   - tags []string
func (_e *MockAgentRepository_Expecter) FindByServiceTypeAndTags(ctx interface{}, serviceTypeID interface{}, tags interface{}) *MockAgentRepository_FindByServiceTypeAndTags_Call {
	return &MockAgentRepository_FindByServiceTypeAndTags_Call{Call: _e.mock.On("FindByServiceTypeAndTags", ctx, serviceTypeID, tags)}
}

func (_c *MockAgentRepository_FindByServiceTypeAndTags_Call) Run(run func(ctx context.Context, serviceTypeID properties.UUID, tags []string)) *MockAgentRepository_FindByServiceTypeAndTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAgentRepository_FindByServiceTypeAndTags_Call) Return(agents []*Agent, err error) *MockAgentRepository_FindByServiceTypeAndTags_Call {
	_c.Call.Return(agents, err)
	return _c
}

func (_c *MockAgentRepository_FindByServiceTypeAndTags_Call) RunAndReturn(run func(ctx context.Context, serviceTypeID properties.UUID, tags []string) ([]*Agent, error)) *MockAgentRepository_FindByServiceTypeAndTags_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) Get(ctx context.Context, id properties.UUID) (*Agent, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Agent, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Agent); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockAgentRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentRepository_Expecter) Get(ctx interface{}, id interface{}) *MockAgentRepository_Get_Call {
	return &MockAgentRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockAgentRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentRepository_Get_Call) Return(agent *Agent, err error) *MockAgentRepository_Get_Call {
	_c.Call.Return(agent, err)
	return _c
}

func (_c *MockAgentRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Agent, error)) *MockAgentRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Agent], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Agent]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Agent], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Agent]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Agent])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockAgentRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockAgentRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockAgentRepository_List_Call {
	return &MockAgentRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockAgentRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockAgentRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAgentRepository_List_Call) Return(pageRes *PageRes[Agent], err error) *MockAgentRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockAgentRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Agent], error)) *MockAgentRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// MarkInactiveAgentsAsDisconnected provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) MarkInactiveAgentsAsDisconnected(ctx context.Context, inactiveDuration time.Duration) (int64, error) {
	ret := _mock.Called(ctx, inactiveDuration)

	if len(ret) == 0 {
		panic("no return value specified for MarkInactiveAgentsAsDisconnected")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) (int64, error)); ok {
		return returnFunc(ctx, inactiveDuration)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) int64); ok {
		r0 = returnFunc(ctx, inactiveDuration)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = returnFunc(ctx, inactiveDuration)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkInactiveAgentsAsDisconnected'
type MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call struct {
	*mock.Call
}

// MarkInactiveAgentsAsDisconnected is a helper method to define mock.On call
//   - ctx context.Context
//   - inactiveDuration time.Duration
func (_e *MockAgentRepository_Expecter) MarkInactiveAgentsAsDisconnected(ctx interface{}, inactiveDuration interface{}) *MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call {
	return &MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call{Call: _e.mock.On("MarkInactiveAgentsAsDisconnected", ctx, inactiveDuration)}
}

func (_c *MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call) Run(run func(ctx context.Context, inactiveDuration time.Duration)) *MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call) Return(n int64, err error) *MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call) RunAndReturn(run func(ctx context.Context, inactiveDuration time.Duration) (int64, error)) *MockAgentRepository_MarkInactiveAgentsAsDisconnected_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockAgentRepository
func (_mock *MockAgentRepository) Save(ctx context.Context, entity *Agent) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Agent) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAgentRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockAgentRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Agent
func (_e *MockAgentRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockAgentRepository_Save_Call {
	return &MockAgentRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockAgentRepository_Save_Call) Run(run func(ctx context.Context, entity *Agent)) *MockAgentRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Agent
		if args[1] != nil {
			arg1 = args[1].(*Agent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentRepository_Save_Call) Return(err error) *MockAgentRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAgentRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *Agent) error) *MockAgentRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAgentQuerier creates a new instance of MockAgentQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAgentQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAgentQuerier {
	mock := &MockAgentQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAgentQuerier is an autogenerated mock type for the AgentQuerier type
type MockAgentQuerier struct {
	mock.Mock
}

type MockAgentQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAgentQuerier) EXPECT() *MockAgentQuerier_Expecter {
	return &MockAgentQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockAgentQuerier
func (_mock *MockAgentQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockAgentQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockAgentQuerier_AuthScope_Call {
	return &MockAgentQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockAgentQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockAgentQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockAgentQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockAgentQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockAgentQuerier
func (_mock *MockAgentQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockAgentQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAgentQuerier_Expecter) Count(ctx interface{}) *MockAgentQuerier_Count_Call {
	return &MockAgentQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockAgentQuerier_Count_Call) Run(run func(ctx context.Context)) *MockAgentQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAgentQuerier_Count_Call) Return(n int64, err error) *MockAgentQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAgentQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockAgentQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CountByProvider provides a mock function for the type MockAgentQuerier
func (_mock *MockAgentQuerier) CountByProvider(ctx context.Context, providerID properties.UUID) (int64, error) {
	ret := _mock.Called(ctx, providerID)

	if len(ret) == 0 {
		panic("no return value specified for CountByProvider")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (int64, error)); ok {
		return returnFunc(ctx, providerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) int64); ok {
		r0 = returnFunc(ctx, providerID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, providerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentQuerier_CountByProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByProvider'
type MockAgentQuerier_CountByProvider_Call struct {
	*mock.Call
}

// CountByProvider is a helper method to define mock.On call
//   - ctx context.Context
//   - providerID properties.UUID
func (_e *MockAgentQuerier_Expecter) CountByProvider(ctx interface{}, providerID interface{}) *MockAgentQuerier_CountByProvider_Call {
	return &MockAgentQuerier_CountByProvider_Call{Call: _e.mock.On("CountByProvider", ctx, providerID)}
}

func (_c *MockAgentQuerier_CountByProvider_Call) Run(run func(ctx context.Context, providerID properties.UUID)) *MockAgentQuerier_CountByProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentQuerier_CountByProvider_Call) Return(n int64, err error) *MockAgentQuerier_CountByProvider_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAgentQuerier_CountByProvider_Call) RunAndReturn(run func(ctx context.Context, providerID properties.UUID) (int64, error)) *MockAgentQuerier_CountByProvider_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockAgentQuerier
func (_mock *MockAgentQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockAgentQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockAgentQuerier_Exists_Call {
	return &MockAgentQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockAgentQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentQuerier_Exists_Call) Return(b bool, err error) *MockAgentQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockAgentQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockAgentQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FindByServiceTypeAndTags provides a mock function for the type MockAgentQuerier
func (_mock *MockAgentQuerier) FindByServiceTypeAndTags(ctx context.Context, serviceTypeID properties.UUID, tags []string) ([]*Agent, error) {
	ret := _mock.Called(ctx, serviceTypeID, tags)

	if len(ret) == 0 {
		panic("no return value specified for FindByServiceTypeAndTags")
	}

	var r0 []*Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, []string) ([]*Agent, error)); ok {
		return returnFunc(ctx, serviceTypeID, tags)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, []string) []*Agent); ok {
		r0 = returnFunc(ctx, serviceTypeID, tags)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, []string) error); ok {
		r1 = returnFunc(ctx, serviceTypeID, tags)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentQuerier_FindByServiceTypeAndTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByServiceTypeAndTags'
type MockAgentQuerier_FindByServiceTypeAndTags_Call struct {
	*mock.Call
}

// FindByServiceTypeAndTags is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceTypeID properties.UUID
//   - tags []string
func (_e *MockAgentQuerier_Expecter) FindByServiceTypeAndTags(ctx interface{}, serviceTypeID interface{}, tags interface{}) *MockAgentQuerier_FindByServiceTypeAndTags_Call {
	return &MockAgentQuerier_FindByServiceTypeAndTags_Call{Call: _e.mock.On("FindByServiceTypeAndTags", ctx, serviceTypeID, tags)}
}

func (_c *MockAgentQuerier_FindByServiceTypeAndTags_Call) Run(run func(ctx context.Context, serviceTypeID properties.UUID, tags []string)) *MockAgentQuerier_FindByServiceTypeAndTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAgentQuerier_FindByServiceTypeAndTags_Call) Return(agents []*Agent, err error) *MockAgentQuerier_FindByServiceTypeAndTags_Call {
	_c.Call.Return(agents, err)
	return _c
}

func (_c *MockAgentQuerier_FindByServiceTypeAndTags_Call) RunAndReturn(run func(ctx context.Context, serviceTypeID properties.UUID, tags []string) ([]*Agent, error)) *MockAgentQuerier_FindByServiceTypeAndTags_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockAgentQuerier
func (_mock *MockAgentQuerier) Get(ctx context.Context, id properties.UUID) (*Agent, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Agent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Agent, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Agent); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Agent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockAgentQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockAgentQuerier_Get_Call {
	return &MockAgentQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockAgentQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentQuerier_Get_Call) Return(agent *Agent, err error) *MockAgentQuerier_Get_Call {
	_c.Call.Return(agent, err)
	return _c
}

func (_c *MockAgentQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Agent, error)) *MockAgentQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockAgentQuerier
func (_mock *MockAgentQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Agent], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Agent]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Agent], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Agent]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Agent])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockAgentQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockAgentQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockAgentQuerier_List_Call {
	return &MockAgentQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockAgentQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockAgentQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAgentQuerier_List_Call) Return(pageRes *PageRes[Agent], err error) *MockAgentQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockAgentQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Agent], error)) *MockAgentQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAgentTypeRepository creates a new instance of MockAgentTypeRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAgentTypeRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAgentTypeRepository {
	mock := &MockAgentTypeRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAgentTypeRepository is an autogenerated mock type for the AgentTypeRepository type
type MockAgentTypeRepository struct {
	mock.Mock
}

type MockAgentTypeRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAgentTypeRepository) EXPECT() *MockAgentTypeRepository_Expecter {
	return &MockAgentTypeRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockAgentTypeRepository
func (_mock *MockAgentTypeRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockAgentTypeRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentTypeRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockAgentTypeRepository_AuthScope_Call {
	return &MockAgentTypeRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockAgentTypeRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentTypeRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockAgentTypeRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockAgentTypeRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockAgentTypeRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockAgentTypeRepository
func (_mock *MockAgentTypeRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockAgentTypeRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAgentTypeRepository_Expecter) Count(ctx interface{}) *MockAgentTypeRepository_Count_Call {
	return &MockAgentTypeRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockAgentTypeRepository_Count_Call) Run(run func(ctx context.Context)) *MockAgentTypeRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAgentTypeRepository_Count_Call) Return(n int64, err error) *MockAgentTypeRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAgentTypeRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockAgentTypeRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockAgentTypeRepository
func (_mock *MockAgentTypeRepository) Create(ctx context.Context, entity *AgentType) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *AgentType) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAgentTypeRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockAgentTypeRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *AgentType
func (_e *MockAgentTypeRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockAgentTypeRepository_Create_Call {
	return &MockAgentTypeRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockAgentTypeRepository_Create_Call) Run(run func(ctx context.Context, entity *AgentType)) *MockAgentTypeRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *AgentType
		if args[1] != nil {
			arg1 = args[1].(*AgentType)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeRepository_Create_Call) Return(err error) *MockAgentTypeRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAgentTypeRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *AgentType) error) *MockAgentTypeRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockAgentTypeRepository
func (_mock *MockAgentTypeRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAgentTypeRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockAgentTypeRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentTypeRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockAgentTypeRepository_Delete_Call {
	return &MockAgentTypeRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockAgentTypeRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentTypeRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeRepository_Delete_Call) Return(err error) *MockAgentTypeRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAgentTypeRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockAgentTypeRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockAgentTypeRepository
func (_mock *MockAgentTypeRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockAgentTypeRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentTypeRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockAgentTypeRepository_Exists_Call {
	return &MockAgentTypeRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockAgentTypeRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentTypeRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeRepository_Exists_Call) Return(b bool, err error) *MockAgentTypeRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockAgentTypeRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockAgentTypeRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockAgentTypeRepository
func (_mock *MockAgentTypeRepository) Get(ctx context.Context, id properties.UUID) (*AgentType, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *AgentType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*AgentType, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *AgentType); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*AgentType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockAgentTypeRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentTypeRepository_Expecter) Get(ctx interface{}, id interface{}) *MockAgentTypeRepository_Get_Call {
	return &MockAgentTypeRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockAgentTypeRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentTypeRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeRepository_Get_Call) Return(agentType *AgentType, err error) *MockAgentTypeRepository_Get_Call {
	_c.Call.Return(agentType, err)
	return _c
}

func (_c *MockAgentTypeRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*AgentType, error)) *MockAgentTypeRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockAgentTypeRepository
func (_mock *MockAgentTypeRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[AgentType], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[AgentType]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[AgentType], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[AgentType]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[AgentType])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockAgentTypeRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockAgentTypeRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockAgentTypeRepository_List_Call {
	return &MockAgentTypeRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockAgentTypeRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockAgentTypeRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAgentTypeRepository_List_Call) Return(pageRes *PageRes[AgentType], err error) *MockAgentTypeRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockAgentTypeRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[AgentType], error)) *MockAgentTypeRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockAgentTypeRepository
func (_mock *MockAgentTypeRepository) Save(ctx context.Context, entity *AgentType) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *AgentType) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAgentTypeRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockAgentTypeRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *AgentType
func (_e *MockAgentTypeRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockAgentTypeRepository_Save_Call {
	return &MockAgentTypeRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockAgentTypeRepository_Save_Call) Run(run func(ctx context.Context, entity *AgentType)) *MockAgentTypeRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *AgentType
		if args[1] != nil {
			arg1 = args[1].(*AgentType)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeRepository_Save_Call) Return(err error) *MockAgentTypeRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAgentTypeRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *AgentType) error) *MockAgentTypeRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAgentTypeQuerier creates a new instance of MockAgentTypeQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAgentTypeQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAgentTypeQuerier {
	mock := &MockAgentTypeQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAgentTypeQuerier is an autogenerated mock type for the AgentTypeQuerier type
type MockAgentTypeQuerier struct {
	mock.Mock
}

type MockAgentTypeQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAgentTypeQuerier) EXPECT() *MockAgentTypeQuerier_Expecter {
	return &MockAgentTypeQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockAgentTypeQuerier
func (_mock *MockAgentTypeQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockAgentTypeQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentTypeQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockAgentTypeQuerier_AuthScope_Call {
	return &MockAgentTypeQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockAgentTypeQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentTypeQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockAgentTypeQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockAgentTypeQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockAgentTypeQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockAgentTypeQuerier
func (_mock *MockAgentTypeQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockAgentTypeQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAgentTypeQuerier_Expecter) Count(ctx interface{}) *MockAgentTypeQuerier_Count_Call {
	return &MockAgentTypeQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockAgentTypeQuerier_Count_Call) Run(run func(ctx context.Context)) *MockAgentTypeQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAgentTypeQuerier_Count_Call) Return(n int64, err error) *MockAgentTypeQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAgentTypeQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockAgentTypeQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockAgentTypeQuerier
func (_mock *MockAgentTypeQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockAgentTypeQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentTypeQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockAgentTypeQuerier_Exists_Call {
	return &MockAgentTypeQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockAgentTypeQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentTypeQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeQuerier_Exists_Call) Return(b bool, err error) *MockAgentTypeQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockAgentTypeQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockAgentTypeQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockAgentTypeQuerier
func (_mock *MockAgentTypeQuerier) Get(ctx context.Context, id properties.UUID) (*AgentType, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *AgentType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*AgentType, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *AgentType); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*AgentType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockAgentTypeQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockAgentTypeQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockAgentTypeQuerier_Get_Call {
	return &MockAgentTypeQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockAgentTypeQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockAgentTypeQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAgentTypeQuerier_Get_Call) Return(agentType *AgentType, err error) *MockAgentTypeQuerier_Get_Call {
	_c.Call.Return(agentType, err)
	return _c
}

func (_c *MockAgentTypeQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*AgentType, error)) *MockAgentTypeQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockAgentTypeQuerier
func (_mock *MockAgentTypeQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[AgentType], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[AgentType]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[AgentType], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[AgentType]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[AgentType])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAgentTypeQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockAgentTypeQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockAgentTypeQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockAgentTypeQuerier_List_Call {
	return &MockAgentTypeQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockAgentTypeQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockAgentTypeQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAgentTypeQuerier_List_Call) Return(pageRes *PageRes[AgentType], err error) *MockAgentTypeQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockAgentTypeQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[AgentType], error)) *MockAgentTypeQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEntity creates a new instance of MockEntity. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEntity(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEntity {
	mock := &MockEntity{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEntity is an autogenerated mock type for the Entity type
type MockEntity struct {
	mock.Mock
}

type MockEntity_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEntity) EXPECT() *MockEntity_Expecter {
	return &MockEntity_Expecter{mock: &_m.Mock}
}

// GetID provides a mock function for the type MockEntity
func (_mock *MockEntity) GetID() properties.UUID {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetID")
	}

	var r0 properties.UUID
	if returnFunc, ok := ret.Get(0).(func() properties.UUID); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(properties.UUID)
		}
	}
	return r0
}

// MockEntity_GetID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetID'
type MockEntity_GetID_Call struct {
	*mock.Call
}

// GetID is a helper method to define mock.On call
func (_e *MockEntity_Expecter) GetID() *MockEntity_GetID_Call {
	return &MockEntity_GetID_Call{Call: _e.mock.On("GetID")}
}

func (_c *MockEntity_GetID_Call) Run(run func()) *MockEntity_GetID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockEntity_GetID_Call) Return(v properties.UUID) *MockEntity_GetID_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *MockEntity_GetID_Call) RunAndReturn(run func() properties.UUID) *MockEntity_GetID_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBaseEntityRepository creates a new instance of MockBaseEntityRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBaseEntityRepository[T Entity](t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBaseEntityRepository[T] {
	mock := &MockBaseEntityRepository[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBaseEntityRepository is an autogenerated mock type for the BaseEntityRepository type
type MockBaseEntityRepository[T Entity] struct {
	mock.Mock
}

type MockBaseEntityRepository_Expecter[T Entity] struct {
	mock *mock.Mock
}

func (_m *MockBaseEntityRepository[T]) EXPECT() *MockBaseEntityRepository_Expecter[T] {
	return &MockBaseEntityRepository_Expecter[T]{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockBaseEntityRepository
func (_mock *MockBaseEntityRepository[T]) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockBaseEntityRepository_AuthScope_Call[T Entity] struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockBaseEntityRepository_Expecter[T]) AuthScope(ctx interface{}, id interface{}) *MockBaseEntityRepository_AuthScope_Call[T] {
	return &MockBaseEntityRepository_AuthScope_Call[T]{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockBaseEntityRepository_AuthScope_Call[T]) Run(run func(ctx context.Context, id properties.UUID)) *MockBaseEntityRepository_AuthScope_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityRepository_AuthScope_Call[T]) Return(objectScope auth.ObjectScope, err error) *MockBaseEntityRepository_AuthScope_Call[T] {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockBaseEntityRepository_AuthScope_Call[T]) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockBaseEntityRepository_AuthScope_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockBaseEntityRepository
func (_mock *MockBaseEntityRepository[T]) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockBaseEntityRepository_Count_Call[T Entity] struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBaseEntityRepository_Expecter[T]) Count(ctx interface{}) *MockBaseEntityRepository_Count_Call[T] {
	return &MockBaseEntityRepository_Count_Call[T]{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockBaseEntityRepository_Count_Call[T]) Run(run func(ctx context.Context)) *MockBaseEntityRepository_Count_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockBaseEntityRepository_Count_Call[T]) Return(n int64, err error) *MockBaseEntityRepository_Count_Call[T] {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockBaseEntityRepository_Count_Call[T]) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockBaseEntityRepository_Count_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockBaseEntityRepository
func (_mock *MockBaseEntityRepository[T]) Create(ctx context.Context, entity *T) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *T) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBaseEntityRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockBaseEntityRepository_Create_Call[T Entity] struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *T
func (_e *MockBaseEntityRepository_Expecter[T]) Create(ctx interface{}, entity interface{}) *MockBaseEntityRepository_Create_Call[T] {
	return &MockBaseEntityRepository_Create_Call[T]{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockBaseEntityRepository_Create_Call[T]) Run(run func(ctx context.Context, entity *T)) *MockBaseEntityRepository_Create_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *T
		if args[1] != nil {
			arg1 = args[1].(*T)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityRepository_Create_Call[T]) Return(err error) *MockBaseEntityRepository_Create_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBaseEntityRepository_Create_Call[T]) RunAndReturn(run func(ctx context.Context, entity *T) error) *MockBaseEntityRepository_Create_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockBaseEntityRepository
func (_mock *MockBaseEntityRepository[T]) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBaseEntityRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockBaseEntityRepository_Delete_Call[T Entity] struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockBaseEntityRepository_Expecter[T]) Delete(ctx interface{}, id interface{}) *MockBaseEntityRepository_Delete_Call[T] {
	return &MockBaseEntityRepository_Delete_Call[T]{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockBaseEntityRepository_Delete_Call[T]) Run(run func(ctx context.Context, id properties.UUID)) *MockBaseEntityRepository_Delete_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityRepository_Delete_Call[T]) Return(err error) *MockBaseEntityRepository_Delete_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBaseEntityRepository_Delete_Call[T]) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockBaseEntityRepository_Delete_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockBaseEntityRepository
func (_mock *MockBaseEntityRepository[T]) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockBaseEntityRepository_Exists_Call[T Entity] struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockBaseEntityRepository_Expecter[T]) Exists(ctx interface{}, id interface{}) *MockBaseEntityRepository_Exists_Call[T] {
	return &MockBaseEntityRepository_Exists_Call[T]{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockBaseEntityRepository_Exists_Call[T]) Run(run func(ctx context.Context, id properties.UUID)) *MockBaseEntityRepository_Exists_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityRepository_Exists_Call[T]) Return(b bool, err error) *MockBaseEntityRepository_Exists_Call[T] {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockBaseEntityRepository_Exists_Call[T]) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockBaseEntityRepository_Exists_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockBaseEntityRepository
func (_mock *MockBaseEntityRepository[T]) Get(ctx context.Context, id properties.UUID) (*T, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *T
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*T, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *T); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*T)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockBaseEntityRepository_Get_Call[T Entity] struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockBaseEntityRepository_Expecter[T]) Get(ctx interface{}, id interface{}) *MockBaseEntityRepository_Get_Call[T] {
	return &MockBaseEntityRepository_Get_Call[T]{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockBaseEntityRepository_Get_Call[T]) Run(run func(ctx context.Context, id properties.UUID)) *MockBaseEntityRepository_Get_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityRepository_Get_Call[T]) Return(v *T, err error) *MockBaseEntityRepository_Get_Call[T] {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockBaseEntityRepository_Get_Call[T]) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*T, error)) *MockBaseEntityRepository_Get_Call[T] {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockBaseEntityRepository
func (_mock *MockBaseEntityRepository[T]) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[T], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[T]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[T], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[T]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[T])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockBaseEntityRepository_List_Call[T Entity] struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockBaseEntityRepository_Expecter[T]) List(ctx interface{}, scope interface{}, req interface{}) *MockBaseEntityRepository_List_Call[T] {
	return &MockBaseEntityRepository_List_Call[T]{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockBaseEntityRepository_List_Call[T]) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockBaseEntityRepository_List_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBaseEntityRepository_List_Call[T]) Return(pageRes *PageRes[T], err error) *MockBaseEntityRepository_List_Call[T] {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockBaseEntityRepository_List_Call[T]) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[T], error)) *MockBaseEntityRepository_List_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockBaseEntityRepository
func (_mock *MockBaseEntityRepository[T]) Save(ctx context.Context, entity *T) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *T) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBaseEntityRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockBaseEntityRepository_Save_Call[T Entity] struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *T
func (_e *MockBaseEntityRepository_Expecter[T]) Save(ctx interface{}, entity interface{}) *MockBaseEntityRepository_Save_Call[T] {
	return &MockBaseEntityRepository_Save_Call[T]{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockBaseEntityRepository_Save_Call[T]) Run(run func(ctx context.Context, entity *T)) *MockBaseEntityRepository_Save_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *T
		if args[1] != nil {
			arg1 = args[1].(*T)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityRepository_Save_Call[T]) Return(err error) *MockBaseEntityRepository_Save_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBaseEntityRepository_Save_Call[T]) RunAndReturn(run func(ctx context.Context, entity *T) error) *MockBaseEntityRepository_Save_Call[T] {
	_c.Call.Return(run)
	return _c
}

// NewMockBaseEntityQuerier creates a new instance of MockBaseEntityQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBaseEntityQuerier[T Entity](t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBaseEntityQuerier[T] {
	mock := &MockBaseEntityQuerier[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBaseEntityQuerier is an autogenerated mock type for the BaseEntityQuerier type
type MockBaseEntityQuerier[T Entity] struct {
	mock.Mock
}

type MockBaseEntityQuerier_Expecter[T Entity] struct {
	mock *mock.Mock
}

func (_m *MockBaseEntityQuerier[T]) EXPECT() *MockBaseEntityQuerier_Expecter[T] {
	return &MockBaseEntityQuerier_Expecter[T]{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockBaseEntityQuerier
func (_mock *MockBaseEntityQuerier[T]) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockBaseEntityQuerier_AuthScope_Call[T Entity] struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockBaseEntityQuerier_Expecter[T]) AuthScope(ctx interface{}, id interface{}) *MockBaseEntityQuerier_AuthScope_Call[T] {
	return &MockBaseEntityQuerier_AuthScope_Call[T]{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockBaseEntityQuerier_AuthScope_Call[T]) Run(run func(ctx context.Context, id properties.UUID)) *MockBaseEntityQuerier_AuthScope_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityQuerier_AuthScope_Call[T]) Return(objectScope auth.ObjectScope, err error) *MockBaseEntityQuerier_AuthScope_Call[T] {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockBaseEntityQuerier_AuthScope_Call[T]) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockBaseEntityQuerier_AuthScope_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockBaseEntityQuerier
func (_mock *MockBaseEntityQuerier[T]) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockBaseEntityQuerier_Count_Call[T Entity] struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBaseEntityQuerier_Expecter[T]) Count(ctx interface{}) *MockBaseEntityQuerier_Count_Call[T] {
	return &MockBaseEntityQuerier_Count_Call[T]{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockBaseEntityQuerier_Count_Call[T]) Run(run func(ctx context.Context)) *MockBaseEntityQuerier_Count_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockBaseEntityQuerier_Count_Call[T]) Return(n int64, err error) *MockBaseEntityQuerier_Count_Call[T] {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockBaseEntityQuerier_Count_Call[T]) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockBaseEntityQuerier_Count_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockBaseEntityQuerier
func (_mock *MockBaseEntityQuerier[T]) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockBaseEntityQuerier_Exists_Call[T Entity] struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockBaseEntityQuerier_Expecter[T]) Exists(ctx interface{}, id interface{}) *MockBaseEntityQuerier_Exists_Call[T] {
	return &MockBaseEntityQuerier_Exists_Call[T]{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockBaseEntityQuerier_Exists_Call[T]) Run(run func(ctx context.Context, id properties.UUID)) *MockBaseEntityQuerier_Exists_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityQuerier_Exists_Call[T]) Return(b bool, err error) *MockBaseEntityQuerier_Exists_Call[T] {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockBaseEntityQuerier_Exists_Call[T]) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockBaseEntityQuerier_Exists_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockBaseEntityQuerier
func (_mock *MockBaseEntityQuerier[T]) Get(ctx context.Context, id properties.UUID) (*T, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *T
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*T, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *T); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*T)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockBaseEntityQuerier_Get_Call[T Entity] struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockBaseEntityQuerier_Expecter[T]) Get(ctx interface{}, id interface{}) *MockBaseEntityQuerier_Get_Call[T] {
	return &MockBaseEntityQuerier_Get_Call[T]{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockBaseEntityQuerier_Get_Call[T]) Run(run func(ctx context.Context, id properties.UUID)) *MockBaseEntityQuerier_Get_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBaseEntityQuerier_Get_Call[T]) Return(v *T, err error) *MockBaseEntityQuerier_Get_Call[T] {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockBaseEntityQuerier_Get_Call[T]) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*T, error)) *MockBaseEntityQuerier_Get_Call[T] {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockBaseEntityQuerier
func (_mock *MockBaseEntityQuerier[T]) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[T], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[T]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[T], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[T]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[T])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBaseEntityQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockBaseEntityQuerier_List_Call[T Entity] struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockBaseEntityQuerier_Expecter[T]) List(ctx interface{}, scope interface{}, req interface{}) *MockBaseEntityQuerier_List_Call[T] {
	return &MockBaseEntityQuerier_List_Call[T]{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockBaseEntityQuerier_List_Call[T]) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockBaseEntityQuerier_List_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBaseEntityQuerier_List_Call[T]) Return(pageRes *PageRes[T], err error) *MockBaseEntityQuerier_List_Call[T] {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockBaseEntityQuerier_List_Call[T]) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[T], error)) *MockBaseEntityQuerier_List_Call[T] {
	_c.Call.Return(run)
	return _c
}

// NewMockEventRepository creates a new instance of MockEventRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEventRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEventRepository {
	mock := &MockEventRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEventRepository is an autogenerated mock type for the EventRepository type
type MockEventRepository struct {
	mock.Mock
}

type MockEventRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEventRepository) EXPECT() *MockEventRepository_Expecter {
	return &MockEventRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockEventRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockEventRepository_AuthScope_Call {
	return &MockEventRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockEventRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockEventRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockEventRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockEventRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockEventRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEventRepository_Expecter) Count(ctx interface{}) *MockEventRepository_Count_Call {
	return &MockEventRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockEventRepository_Count_Call) Run(run func(ctx context.Context)) *MockEventRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEventRepository_Count_Call) Return(n int64, err error) *MockEventRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockEventRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockEventRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) Create(ctx context.Context, entry *Event) error {
	ret := _mock.Called(ctx, entry)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Event) error); ok {
		r0 = returnFunc(ctx, entry)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockEventRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entry *Event
func (_e *MockEventRepository_Expecter) Create(ctx interface{}, entry interface{}) *MockEventRepository_Create_Call {
	return &MockEventRepository_Create_Call{Call: _e.mock.On("Create", ctx, entry)}
}

func (_c *MockEventRepository_Create_Call) Run(run func(ctx context.Context, entry *Event)) *MockEventRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Event
		if args[1] != nil {
			arg1 = args[1].(*Event)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventRepository_Create_Call) Return(err error) *MockEventRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entry *Event) error) *MockEventRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockEventRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockEventRepository_Delete_Call {
	return &MockEventRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockEventRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventRepository_Delete_Call) Return(err error) *MockEventRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockEventRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockEventRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockEventRepository_Exists_Call {
	return &MockEventRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockEventRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventRepository_Exists_Call) Return(b bool, err error) *MockEventRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockEventRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockEventRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) Get(ctx context.Context, id properties.UUID) (*Event, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Event, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Event); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockEventRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventRepository_Expecter) Get(ctx interface{}, id interface{}) *MockEventRepository_Get_Call {
	return &MockEventRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockEventRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventRepository_Get_Call) Return(event *Event, err error) *MockEventRepository_Get_Call {
	_c.Call.Return(event, err)
	return _c
}

func (_c *MockEventRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Event, error)) *MockEventRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Event], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Event]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Event], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Event]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Event])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockEventRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockEventRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockEventRepository_List_Call {
	return &MockEventRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockEventRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockEventRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventRepository_List_Call) Return(pageRes *PageRes[Event], err error) *MockEventRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockEventRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Event], error)) *MockEventRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListFromSequence provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) ListFromSequence(ctx context.Context, fromSequenceNumber int64, limit int) ([]*Event, error) {
	ret := _mock.Called(ctx, fromSequenceNumber, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListFromSequence")
	}

	var r0 []*Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int) ([]*Event, error)); ok {
		return returnFunc(ctx, fromSequenceNumber, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int) []*Event); ok {
		r0 = returnFunc(ctx, fromSequenceNumber, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, int) error); ok {
		r1 = returnFunc(ctx, fromSequenceNumber, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventRepository_ListFromSequence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFromSequence'
type MockEventRepository_ListFromSequence_Call struct {
	*mock.Call
}

// ListFromSequence is a helper method to define mock.On call
//   - ctx context.Context
//   - fromSequenceNumber int64
//   - limit int
func (_e *MockEventRepository_Expecter) ListFromSequence(ctx interface{}, fromSequenceNumber interface{}, limit interface{}) *MockEventRepository_ListFromSequence_Call {
	return &MockEventRepository_ListFromSequence_Call{Call: _e.mock.On("ListFromSequence", ctx, fromSequenceNumber, limit)}
}

func (_c *MockEventRepository_ListFromSequence_Call) Run(run func(ctx context.Context, fromSequenceNumber int64, limit int)) *MockEventRepository_ListFromSequence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventRepository_ListFromSequence_Call) Return(events []*Event, err error) *MockEventRepository_ListFromSequence_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *MockEventRepository_ListFromSequence_Call) RunAndReturn(run func(ctx context.Context, fromSequenceNumber int64, limit int) ([]*Event, error)) *MockEventRepository_ListFromSequence_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) Save(ctx context.Context, entity *Event) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Event) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockEventRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Event
func (_e *MockEventRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockEventRepository_Save_Call {
	return &MockEventRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockEventRepository_Save_Call) Run(run func(ctx context.Context, entity *Event)) *MockEventRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Event
		if args[1] != nil {
			arg1 = args[1].(*Event)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventRepository_Save_Call) Return(err error) *MockEventRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *Event) error) *MockEventRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// ServiceUptime provides a mock function for the type MockEventRepository
func (_mock *MockEventRepository) ServiceUptime(ctx context.Context, serviceID properties.UUID, start time.Time, end time.Time) (uint64, uint64, error) {
	ret := _mock.Called(ctx, serviceID, start, end)

	if len(ret) == 0 {
		panic("no return value specified for ServiceUptime")
	}

	var r0 uint64
	var r1 uint64
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, time.Time, time.Time) (uint64, uint64, error)); ok {
		return returnFunc(ctx, serviceID, start, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, time.Time, time.Time) uint64); ok {
		r0 = returnFunc(ctx, serviceID, start, end)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, time.Time, time.Time) uint64); ok {
		r1 = returnFunc(ctx, serviceID, start, end)
	} else {
		r1 = ret.Get(1).(uint64)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, properties.UUID, time.Time, time.Time) error); ok {
		r2 = returnFunc(ctx, serviceID, start, end)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockEventRepository_ServiceUptime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceUptime'
type MockEventRepository_ServiceUptime_Call struct {
	*mock.Call
}

// ServiceUptime is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID properties.UUID
//   - start time.Time
//   - end time.Time
func (_e *MockEventRepository_Expecter) ServiceUptime(ctx interface{}, serviceID interface{}, start interface{}, end interface{}) *MockEventRepository_ServiceUptime_Call {
	return &MockEventRepository_ServiceUptime_Call{Call: _e.mock.On("ServiceUptime", ctx, serviceID, start, end)}
}

func (_c *MockEventRepository_ServiceUptime_Call) Run(run func(ctx context.Context, serviceID properties.UUID, start time.Time, end time.Time)) *MockEventRepository_ServiceUptime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockEventRepository_ServiceUptime_Call) Return(uptimeSeconds uint64, downtimeSeconds uint64, err error) *MockEventRepository_ServiceUptime_Call {
	_c.Call.Return(uptimeSeconds, downtimeSeconds, err)
	return _c
}

func (_c *MockEventRepository_ServiceUptime_Call) RunAndReturn(run func(ctx context.Context, serviceID properties.UUID, start time.Time, end time.Time) (uint64, uint64, error)) *MockEventRepository_ServiceUptime_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEventQuerier creates a new instance of MockEventQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEventQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEventQuerier {
	mock := &MockEventQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEventQuerier is an autogenerated mock type for the EventQuerier type
type MockEventQuerier struct {
	mock.Mock
}

type MockEventQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEventQuerier) EXPECT() *MockEventQuerier_Expecter {
	return &MockEventQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockEventQuerier
func (_mock *MockEventQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockEventQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockEventQuerier_AuthScope_Call {
	return &MockEventQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockEventQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockEventQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockEventQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockEventQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockEventQuerier
func (_mock *MockEventQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockEventQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEventQuerier_Expecter) Count(ctx interface{}) *MockEventQuerier_Count_Call {
	return &MockEventQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockEventQuerier_Count_Call) Run(run func(ctx context.Context)) *MockEventQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEventQuerier_Count_Call) Return(n int64, err error) *MockEventQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockEventQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockEventQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockEventQuerier
func (_mock *MockEventQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockEventQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockEventQuerier_Exists_Call {
	return &MockEventQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockEventQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventQuerier_Exists_Call) Return(b bool, err error) *MockEventQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockEventQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockEventQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockEventQuerier
func (_mock *MockEventQuerier) Get(ctx context.Context, id properties.UUID) (*Event, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Event, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Event); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockEventQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockEventQuerier_Get_Call {
	return &MockEventQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockEventQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventQuerier_Get_Call) Return(event *Event, err error) *MockEventQuerier_Get_Call {
	_c.Call.Return(event, err)
	return _c
}

func (_c *MockEventQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Event, error)) *MockEventQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockEventQuerier
func (_mock *MockEventQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Event], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Event]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Event], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Event]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Event])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockEventQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockEventQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockEventQuerier_List_Call {
	return &MockEventQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockEventQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockEventQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventQuerier_List_Call) Return(pageRes *PageRes[Event], err error) *MockEventQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockEventQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Event], error)) *MockEventQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListFromSequence provides a mock function for the type MockEventQuerier
func (_mock *MockEventQuerier) ListFromSequence(ctx context.Context, fromSequenceNumber int64, limit int) ([]*Event, error) {
	ret := _mock.Called(ctx, fromSequenceNumber, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListFromSequence")
	}

	var r0 []*Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int) ([]*Event, error)); ok {
		return returnFunc(ctx, fromSequenceNumber, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int) []*Event); ok {
		r0 = returnFunc(ctx, fromSequenceNumber, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, int) error); ok {
		r1 = returnFunc(ctx, fromSequenceNumber, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventQuerier_ListFromSequence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFromSequence'
type MockEventQuerier_ListFromSequence_Call struct {
	*mock.Call
}

// ListFromSequence is a helper method to define mock.On call
//   - ctx context.Context
//   - fromSequenceNumber int64
//   - limit int
func (_e *MockEventQuerier_Expecter) ListFromSequence(ctx interface{}, fromSequenceNumber interface{}, limit interface{}) *MockEventQuerier_ListFromSequence_Call {
	return &MockEventQuerier_ListFromSequence_Call{Call: _e.mock.On("ListFromSequence", ctx, fromSequenceNumber, limit)}
}

func (_c *MockEventQuerier_ListFromSequence_Call) Run(run func(ctx context.Context, fromSequenceNumber int64, limit int)) *MockEventQuerier_ListFromSequence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventQuerier_ListFromSequence_Call) Return(events []*Event, err error) *MockEventQuerier_ListFromSequence_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *MockEventQuerier_ListFromSequence_Call) RunAndReturn(run func(ctx context.Context, fromSequenceNumber int64, limit int) ([]*Event, error)) *MockEventQuerier_ListFromSequence_Call {
	_c.Call.Return(run)
	return _c
}

// ServiceUptime provides a mock function for the type MockEventQuerier
func (_mock *MockEventQuerier) ServiceUptime(ctx context.Context, serviceID properties.UUID, start time.Time, end time.Time) (uint64, uint64, error) {
	ret := _mock.Called(ctx, serviceID, start, end)

	if len(ret) == 0 {
		panic("no return value specified for ServiceUptime")
	}

	var r0 uint64
	var r1 uint64
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, time.Time, time.Time) (uint64, uint64, error)); ok {
		return returnFunc(ctx, serviceID, start, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, time.Time, time.Time) uint64); ok {
		r0 = returnFunc(ctx, serviceID, start, end)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, time.Time, time.Time) uint64); ok {
		r1 = returnFunc(ctx, serviceID, start, end)
	} else {
		r1 = ret.Get(1).(uint64)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, properties.UUID, time.Time, time.Time) error); ok {
		r2 = returnFunc(ctx, serviceID, start, end)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockEventQuerier_ServiceUptime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceUptime'
type MockEventQuerier_ServiceUptime_Call struct {
	*mock.Call
}

// ServiceUptime is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID properties.UUID
//   - start time.Time
//   - end time.Time
func (_e *MockEventQuerier_Expecter) ServiceUptime(ctx interface{}, serviceID interface{}, start interface{}, end interface{}) *MockEventQuerier_ServiceUptime_Call {
	return &MockEventQuerier_ServiceUptime_Call{Call: _e.mock.On("ServiceUptime", ctx, serviceID, start, end)}
}

func (_c *MockEventQuerier_ServiceUptime_Call) Run(run func(ctx context.Context, serviceID properties.UUID, start time.Time, end time.Time)) *MockEventQuerier_ServiceUptime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockEventQuerier_ServiceUptime_Call) Return(uptimeSeconds uint64, downtimeSeconds uint64, err error) *MockEventQuerier_ServiceUptime_Call {
	_c.Call.Return(uptimeSeconds, downtimeSeconds, err)
	return _c
}

func (_c *MockEventQuerier_ServiceUptime_Call) RunAndReturn(run func(ctx context.Context, serviceID properties.UUID, start time.Time, end time.Time) (uint64, uint64, error)) *MockEventQuerier_ServiceUptime_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEventSubscriptionCommander creates a new instance of MockEventSubscriptionCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEventSubscriptionCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEventSubscriptionCommander {
	mock := &MockEventSubscriptionCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEventSubscriptionCommander is an autogenerated mock type for the EventSubscriptionCommander type
type MockEventSubscriptionCommander struct {
	mock.Mock
}

type MockEventSubscriptionCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEventSubscriptionCommander) EXPECT() *MockEventSubscriptionCommander_Expecter {
	return &MockEventSubscriptionCommander_Expecter{mock: &_m.Mock}
}

// AcknowledgeEvents provides a mock function for the type MockEventSubscriptionCommander
func (_mock *MockEventSubscriptionCommander) AcknowledgeEvents(ctx context.Context, subscriberID string, instanceID string, lastEventSequenceProcessed int64) (*EventSubscription, error) {
	ret := _mock.Called(ctx, subscriberID, instanceID, lastEventSequenceProcessed)

	if len(ret) == 0 {
		panic("no return value specified for AcknowledgeEvents")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) (*EventSubscription, error)); ok {
		return returnFunc(ctx, subscriberID, instanceID, lastEventSequenceProcessed)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) *EventSubscription); ok {
		r0 = returnFunc(ctx, subscriberID, instanceID, lastEventSequenceProcessed)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int64) error); ok {
		r1 = returnFunc(ctx, subscriberID, instanceID, lastEventSequenceProcessed)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionCommander_AcknowledgeEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcknowledgeEvents'
type MockEventSubscriptionCommander_AcknowledgeEvents_Call struct {
	*mock.Call
}

// AcknowledgeEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
//   - instanceID string
//   - lastEventSequenceProcessed int64
func (_e *MockEventSubscriptionCommander_Expecter) AcknowledgeEvents(ctx interface{}, subscriberID interface{}, instanceID interface{}, lastEventSequenceProcessed interface{}) *MockEventSubscriptionCommander_AcknowledgeEvents_Call {
	return &MockEventSubscriptionCommander_AcknowledgeEvents_Call{Call: _e.mock.On("AcknowledgeEvents", ctx, subscriberID, instanceID, lastEventSequenceProcessed)}
}

func (_c *MockEventSubscriptionCommander_AcknowledgeEvents_Call) Run(run func(ctx context.Context, subscriberID string, instanceID string, lastEventSequenceProcessed int64)) *MockEventSubscriptionCommander_AcknowledgeEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionCommander_AcknowledgeEvents_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionCommander_AcknowledgeEvents_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionCommander_AcknowledgeEvents_Call) RunAndReturn(run func(ctx context.Context, subscriberID string, instanceID string, lastEventSequenceProcessed int64) (*EventSubscription, error)) *MockEventSubscriptionCommander_AcknowledgeEvents_Call {
	_c.Call.Return(run)
	return _c
}

// AcquireLease provides a mock function for the type MockEventSubscriptionCommander
func (_mock *MockEventSubscriptionCommander) AcquireLease(ctx context.Context, subscriberID string, instanceID string, duration time.Duration) (*EventSubscription, error) {
	ret := _mock.Called(ctx, subscriberID, instanceID, duration)

	if len(ret) == 0 {
		panic("no return value specified for AcquireLease")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) (*EventSubscription, error)); ok {
		return returnFunc(ctx, subscriberID, instanceID, duration)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *EventSubscription); ok {
		r0 = returnFunc(ctx, subscriberID, instanceID, duration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, time.Duration) error); ok {
		r1 = returnFunc(ctx, subscriberID, instanceID, duration)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionCommander_AcquireLease_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcquireLease'
type MockEventSubscriptionCommander_AcquireLease_Call struct {
	*mock.Call
}

// AcquireLease is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
//   - instanceID string
//   - duration time.Duration
func (_e *MockEventSubscriptionCommander_Expecter) AcquireLease(ctx interface{}, subscriberID interface{}, instanceID interface{}, duration interface{}) *MockEventSubscriptionCommander_AcquireLease_Call {
	return &MockEventSubscriptionCommander_AcquireLease_Call{Call: _e.mock.On("AcquireLease", ctx, subscriberID, instanceID, duration)}
}

func (_c *MockEventSubscriptionCommander_AcquireLease_Call) Run(run func(ctx context.Context, subscriberID string, instanceID string, duration time.Duration)) *MockEventSubscriptionCommander_AcquireLease_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 time.Duration
		if args[3] != nil {
			arg3 = args[3].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionCommander_AcquireLease_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionCommander_AcquireLease_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionCommander_AcquireLease_Call) RunAndReturn(run func(ctx context.Context, subscriberID string, instanceID string, duration time.Duration) (*EventSubscription, error)) *MockEventSubscriptionCommander_AcquireLease_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockEventSubscriptionCommander
func (_mock *MockEventSubscriptionCommander) Delete(ctx context.Context, subscriberID string) error {
	ret := _mock.Called(ctx, subscriberID)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, subscriberID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventSubscriptionCommander_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockEventSubscriptionCommander_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
func (_e *MockEventSubscriptionCommander_Expecter) Delete(ctx interface{}, subscriberID interface{}) *MockEventSubscriptionCommander_Delete_Call {
	return &MockEventSubscriptionCommander_Delete_Call{Call: _e.mock.On("Delete", ctx, subscriberID)}
}

func (_c *MockEventSubscriptionCommander_Delete_Call) Run(run func(ctx context.Context, subscriberID string)) *MockEventSubscriptionCommander_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionCommander_Delete_Call) Return(err error) *MockEventSubscriptionCommander_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventSubscriptionCommander_Delete_Call) RunAndReturn(run func(ctx context.Context, subscriberID string) error) *MockEventSubscriptionCommander_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// ReleaseLease provides a mock function for the type MockEventSubscriptionCommander
func (_mock *MockEventSubscriptionCommander) ReleaseLease(ctx context.Context, subscriberID string, instanceID string) (*EventSubscription, error) {
	ret := _mock.Called(ctx, subscriberID, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseLease")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*EventSubscription, error)); ok {
		return returnFunc(ctx, subscriberID, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *EventSubscription); ok {
		r0 = returnFunc(ctx, subscriberID, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, subscriberID, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionCommander_ReleaseLease_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseLease'
type MockEventSubscriptionCommander_ReleaseLease_Call struct {
	*mock.Call
}

// ReleaseLease is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
//   - instanceID string
func (_e *MockEventSubscriptionCommander_Expecter) ReleaseLease(ctx interface{}, subscriberID interface{}, instanceID interface{}) *MockEventSubscriptionCommander_ReleaseLease_Call {
	return &MockEventSubscriptionCommander_ReleaseLease_Call{Call: _e.mock.On("ReleaseLease", ctx, subscriberID, instanceID)}
}

func (_c *MockEventSubscriptionCommander_ReleaseLease_Call) Run(run func(ctx context.Context, subscriberID string, instanceID string)) *MockEventSubscriptionCommander_ReleaseLease_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionCommander_ReleaseLease_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionCommander_ReleaseLease_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionCommander_ReleaseLease_Call) RunAndReturn(run func(ctx context.Context, subscriberID string, instanceID string) (*EventSubscription, error)) *MockEventSubscriptionCommander_ReleaseLease_Call {
	_c.Call.Return(run)
	return _c
}

// RenewLease provides a mock function for the type MockEventSubscriptionCommander
func (_mock *MockEventSubscriptionCommander) RenewLease(ctx context.Context, subscriberID string, instanceID string, duration time.Duration) (*EventSubscription, error) {
	ret := _mock.Called(ctx, subscriberID, instanceID, duration)

	if len(ret) == 0 {
		panic("no return value specified for RenewLease")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) (*EventSubscription, error)); ok {
		return returnFunc(ctx, subscriberID, instanceID, duration)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *EventSubscription); ok {
		r0 = returnFunc(ctx, subscriberID, instanceID, duration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, time.Duration) error); ok {
		r1 = returnFunc(ctx, subscriberID, instanceID, duration)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionCommander_RenewLease_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenewLease'
type MockEventSubscriptionCommander_RenewLease_Call struct {
	*mock.Call
}

// RenewLease is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
//   - instanceID string
//   - duration time.Duration
func (_e *MockEventSubscriptionCommander_Expecter) RenewLease(ctx interface{}, subscriberID interface{}, instanceID interface{}, duration interface{}) *MockEventSubscriptionCommander_RenewLease_Call {
	return &MockEventSubscriptionCommander_RenewLease_Call{Call: _e.mock.On("RenewLease", ctx, subscriberID, instanceID, duration)}
}

func (_c *MockEventSubscriptionCommander_RenewLease_Call) Run(run func(ctx context.Context, subscriberID string, instanceID string, duration time.Duration)) *MockEventSubscriptionCommander_RenewLease_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 time.Duration
		if args[3] != nil {
			arg3 = args[3].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionCommander_RenewLease_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionCommander_RenewLease_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionCommander_RenewLease_Call) RunAndReturn(run func(ctx context.Context, subscriberID string, instanceID string, duration time.Duration) (*EventSubscription, error)) *MockEventSubscriptionCommander_RenewLease_Call {
	_c.Call.Return(run)
	return _c
}

// SetActive provides a mock function for the type MockEventSubscriptionCommander
func (_mock *MockEventSubscriptionCommander) SetActive(ctx context.Context, subscriberID string, isActive bool) (*EventSubscription, error) {
	ret := _mock.Called(ctx, subscriberID, isActive)

	if len(ret) == 0 {
		panic("no return value specified for SetActive")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) (*EventSubscription, error)); ok {
		return returnFunc(ctx, subscriberID, isActive)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) *EventSubscription); ok {
		r0 = returnFunc(ctx, subscriberID, isActive)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = returnFunc(ctx, subscriberID, isActive)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionCommander_SetActive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetActive'
type MockEventSubscriptionCommander_SetActive_Call struct {
	*mock.Call
}

// SetActive is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
//   - isActive bool
func (_e *MockEventSubscriptionCommander_Expecter) SetActive(ctx interface{}, subscriberID interface{}, isActive interface{}) *MockEventSubscriptionCommander_SetActive_Call {
	return &MockEventSubscriptionCommander_SetActive_Call{Call: _e.mock.On("SetActive", ctx, subscriberID, isActive)}
}

func (_c *MockEventSubscriptionCommander_SetActive_Call) Run(run func(ctx context.Context, subscriberID string, isActive bool)) *MockEventSubscriptionCommander_SetActive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionCommander_SetActive_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionCommander_SetActive_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionCommander_SetActive_Call) RunAndReturn(run func(ctx context.Context, subscriberID string, isActive bool) (*EventSubscription, error)) *MockEventSubscriptionCommander_SetActive_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProgress provides a mock function for the type MockEventSubscriptionCommander
func (_mock *MockEventSubscriptionCommander) UpdateProgress(ctx context.Context, subscriberID string, lastEventSequenceProcessed int64) (*EventSubscription, error) {
	ret := _mock.Called(ctx, subscriberID, lastEventSequenceProcessed)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProgress")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int64) (*EventSubscription, error)); ok {
		return returnFunc(ctx, subscriberID, lastEventSequenceProcessed)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int64) *EventSubscription); ok {
		r0 = returnFunc(ctx, subscriberID, lastEventSequenceProcessed)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = returnFunc(ctx, subscriberID, lastEventSequenceProcessed)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionCommander_UpdateProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProgress'
type MockEventSubscriptionCommander_UpdateProgress_Call struct {
	*mock.Call
}

// UpdateProgress is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
//   - lastEventSequenceProcessed int64
func (_e *MockEventSubscriptionCommander_Expecter) UpdateProgress(ctx interface{}, subscriberID interface{}, lastEventSequenceProcessed interface{}) *MockEventSubscriptionCommander_UpdateProgress_Call {
	return &MockEventSubscriptionCommander_UpdateProgress_Call{Call: _e.mock.On("UpdateProgress", ctx, subscriberID, lastEventSequenceProcessed)}
}

func (_c *MockEventSubscriptionCommander_UpdateProgress_Call) Run(run func(ctx context.Context, subscriberID string, lastEventSequenceProcessed int64)) *MockEventSubscriptionCommander_UpdateProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionCommander_UpdateProgress_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionCommander_UpdateProgress_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionCommander_UpdateProgress_Call) RunAndReturn(run func(ctx context.Context, subscriberID string, lastEventSequenceProcessed int64) (*EventSubscription, error)) *MockEventSubscriptionCommander_UpdateProgress_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEventSubscriptionRepository creates a new instance of MockEventSubscriptionRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEventSubscriptionRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEventSubscriptionRepository {
	mock := &MockEventSubscriptionRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEventSubscriptionRepository is an autogenerated mock type for the EventSubscriptionRepository type
type MockEventSubscriptionRepository struct {
	mock.Mock
}

type MockEventSubscriptionRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEventSubscriptionRepository) EXPECT() *MockEventSubscriptionRepository_Expecter {
	return &MockEventSubscriptionRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockEventSubscriptionRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventSubscriptionRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockEventSubscriptionRepository_AuthScope_Call {
	return &MockEventSubscriptionRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockEventSubscriptionRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventSubscriptionRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockEventSubscriptionRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockEventSubscriptionRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockEventSubscriptionRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockEventSubscriptionRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEventSubscriptionRepository_Expecter) Count(ctx interface{}) *MockEventSubscriptionRepository_Count_Call {
	return &MockEventSubscriptionRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockEventSubscriptionRepository_Count_Call) Run(run func(ctx context.Context)) *MockEventSubscriptionRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_Count_Call) Return(n int64, err error) *MockEventSubscriptionRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockEventSubscriptionRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockEventSubscriptionRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) Create(ctx context.Context, entity *EventSubscription) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *EventSubscription) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventSubscriptionRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockEventSubscriptionRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *EventSubscription
func (_e *MockEventSubscriptionRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockEventSubscriptionRepository_Create_Call {
	return &MockEventSubscriptionRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockEventSubscriptionRepository_Create_Call) Run(run func(ctx context.Context, entity *EventSubscription)) *MockEventSubscriptionRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *EventSubscription
		if args[1] != nil {
			arg1 = args[1].(*EventSubscription)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_Create_Call) Return(err error) *MockEventSubscriptionRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventSubscriptionRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *EventSubscription) error) *MockEventSubscriptionRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventSubscriptionRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockEventSubscriptionRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventSubscriptionRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockEventSubscriptionRepository_Delete_Call {
	return &MockEventSubscriptionRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockEventSubscriptionRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventSubscriptionRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_Delete_Call) Return(err error) *MockEventSubscriptionRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventSubscriptionRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockEventSubscriptionRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBySubscriberID provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) DeleteBySubscriberID(ctx context.Context, subscriberID string) error {
	ret := _mock.Called(ctx, subscriberID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBySubscriberID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, subscriberID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventSubscriptionRepository_DeleteBySubscriberID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBySubscriberID'
type MockEventSubscriptionRepository_DeleteBySubscriberID_Call struct {
	*mock.Call
}

// DeleteBySubscriberID is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
func (_e *MockEventSubscriptionRepository_Expecter) DeleteBySubscriberID(ctx interface{}, subscriberID interface{}) *MockEventSubscriptionRepository_DeleteBySubscriberID_Call {
	return &MockEventSubscriptionRepository_DeleteBySubscriberID_Call{Call: _e.mock.On("DeleteBySubscriberID", ctx, subscriberID)}
}

func (_c *MockEventSubscriptionRepository_DeleteBySubscriberID_Call) Run(run func(ctx context.Context, subscriberID string)) *MockEventSubscriptionRepository_DeleteBySubscriberID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_DeleteBySubscriberID_Call) Return(err error) *MockEventSubscriptionRepository_DeleteBySubscriberID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventSubscriptionRepository_DeleteBySubscriberID_Call) RunAndReturn(run func(ctx context.Context, subscriberID string) error) *MockEventSubscriptionRepository_DeleteBySubscriberID_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockEventSubscriptionRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventSubscriptionRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockEventSubscriptionRepository_Exists_Call {
	return &MockEventSubscriptionRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockEventSubscriptionRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventSubscriptionRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_Exists_Call) Return(b bool, err error) *MockEventSubscriptionRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockEventSubscriptionRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockEventSubscriptionRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsBySubscriberID provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) ExistsBySubscriberID(ctx context.Context, subscriberID string) (bool, error) {
	ret := _mock.Called(ctx, subscriberID)

	if len(ret) == 0 {
		panic("no return value specified for ExistsBySubscriberID")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, subscriberID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, subscriberID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, subscriberID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionRepository_ExistsBySubscriberID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsBySubscriberID'
type MockEventSubscriptionRepository_ExistsBySubscriberID_Call struct {
	*mock.Call
}

// ExistsBySubscriberID is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
func (_e *MockEventSubscriptionRepository_Expecter) ExistsBySubscriberID(ctx interface{}, subscriberID interface{}) *MockEventSubscriptionRepository_ExistsBySubscriberID_Call {
	return &MockEventSubscriptionRepository_ExistsBySubscriberID_Call{Call: _e.mock.On("ExistsBySubscriberID", ctx, subscriberID)}
}

func (_c *MockEventSubscriptionRepository_ExistsBySubscriberID_Call) Run(run func(ctx context.Context, subscriberID string)) *MockEventSubscriptionRepository_ExistsBySubscriberID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_ExistsBySubscriberID_Call) Return(b bool, err error) *MockEventSubscriptionRepository_ExistsBySubscriberID_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockEventSubscriptionRepository_ExistsBySubscriberID_Call) RunAndReturn(run func(ctx context.Context, subscriberID string) (bool, error)) *MockEventSubscriptionRepository_ExistsBySubscriberID_Call {
	_c.Call.Return(run)
	return _c
}

// FindBySubscriberID provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) FindBySubscriberID(ctx context.Context, subscriberID string) (*EventSubscription, error) {
	ret := _mock.Called(ctx, subscriberID)

	if len(ret) == 0 {
		panic("no return value specified for FindBySubscriberID")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*EventSubscription, error)); ok {
		return returnFunc(ctx, subscriberID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *EventSubscription); ok {
		r0 = returnFunc(ctx, subscriberID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, subscriberID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionRepository_FindBySubscriberID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBySubscriberID'
type MockEventSubscriptionRepository_FindBySubscriberID_Call struct {
	*mock.Call
}

// FindBySubscriberID is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
func (_e *MockEventSubscriptionRepository_Expecter) FindBySubscriberID(ctx interface{}, subscriberID interface{}) *MockEventSubscriptionRepository_FindBySubscriberID_Call {
	return &MockEventSubscriptionRepository_FindBySubscriberID_Call{Call: _e.mock.On("FindBySubscriberID", ctx, subscriberID)}
}

func (_c *MockEventSubscriptionRepository_FindBySubscriberID_Call) Run(run func(ctx context.Context, subscriberID string)) *MockEventSubscriptionRepository_FindBySubscriberID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_FindBySubscriberID_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionRepository_FindBySubscriberID_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionRepository_FindBySubscriberID_Call) RunAndReturn(run func(ctx context.Context, subscriberID string) (*EventSubscription, error)) *MockEventSubscriptionRepository_FindBySubscriberID_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) Get(ctx context.Context, id properties.UUID) (*EventSubscription, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*EventSubscription, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *EventSubscription); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockEventSubscriptionRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventSubscriptionRepository_Expecter) Get(ctx interface{}, id interface{}) *MockEventSubscriptionRepository_Get_Call {
	return &MockEventSubscriptionRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockEventSubscriptionRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventSubscriptionRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_Get_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionRepository_Get_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*EventSubscription, error)) *MockEventSubscriptionRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[EventSubscription], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[EventSubscription]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[EventSubscription], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[EventSubscription]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[EventSubscription])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockEventSubscriptionRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockEventSubscriptionRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockEventSubscriptionRepository_List_Call {
	return &MockEventSubscriptionRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockEventSubscriptionRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockEventSubscriptionRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_List_Call) Return(pageRes *PageRes[EventSubscription], err error) *MockEventSubscriptionRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockEventSubscriptionRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[EventSubscription], error)) *MockEventSubscriptionRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListExpiredLeases provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) ListExpiredLeases(ctx context.Context) ([]*EventSubscription, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListExpiredLeases")
	}

	var r0 []*EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*EventSubscription, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*EventSubscription); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionRepository_ListExpiredLeases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExpiredLeases'
type MockEventSubscriptionRepository_ListExpiredLeases_Call struct {
	*mock.Call
}

// ListExpiredLeases is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEventSubscriptionRepository_Expecter) ListExpiredLeases(ctx interface{}) *MockEventSubscriptionRepository_ListExpiredLeases_Call {
	return &MockEventSubscriptionRepository_ListExpiredLeases_Call{Call: _e.mock.On("ListExpiredLeases", ctx)}
}

func (_c *MockEventSubscriptionRepository_ListExpiredLeases_Call) Run(run func(ctx context.Context)) *MockEventSubscriptionRepository_ListExpiredLeases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_ListExpiredLeases_Call) Return(eventSubscriptions []*EventSubscription, err error) *MockEventSubscriptionRepository_ListExpiredLeases_Call {
	_c.Call.Return(eventSubscriptions, err)
	return _c
}

func (_c *MockEventSubscriptionRepository_ListExpiredLeases_Call) RunAndReturn(run func(ctx context.Context) ([]*EventSubscription, error)) *MockEventSubscriptionRepository_ListExpiredLeases_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockEventSubscriptionRepository
func (_mock *MockEventSubscriptionRepository) Save(ctx context.Context, entity *EventSubscription) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *EventSubscription) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventSubscriptionRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockEventSubscriptionRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *EventSubscription
func (_e *MockEventSubscriptionRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockEventSubscriptionRepository_Save_Call {
	return &MockEventSubscriptionRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockEventSubscriptionRepository_Save_Call) Run(run func(ctx context.Context, entity *EventSubscription)) *MockEventSubscriptionRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *EventSubscription
		if args[1] != nil {
			arg1 = args[1].(*EventSubscription)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionRepository_Save_Call) Return(err error) *MockEventSubscriptionRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventSubscriptionRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *EventSubscription) error) *MockEventSubscriptionRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEventSubscriptionQuerier creates a new instance of MockEventSubscriptionQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEventSubscriptionQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEventSubscriptionQuerier {
	mock := &MockEventSubscriptionQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEventSubscriptionQuerier is an autogenerated mock type for the EventSubscriptionQuerier type
type MockEventSubscriptionQuerier struct {
	mock.Mock
}

type MockEventSubscriptionQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEventSubscriptionQuerier) EXPECT() *MockEventSubscriptionQuerier_Expecter {
	return &MockEventSubscriptionQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockEventSubscriptionQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventSubscriptionQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockEventSubscriptionQuerier_AuthScope_Call {
	return &MockEventSubscriptionQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockEventSubscriptionQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventSubscriptionQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockEventSubscriptionQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockEventSubscriptionQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockEventSubscriptionQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEventSubscriptionQuerier_Expecter) Count(ctx interface{}) *MockEventSubscriptionQuerier_Count_Call {
	return &MockEventSubscriptionQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockEventSubscriptionQuerier_Count_Call) Run(run func(ctx context.Context)) *MockEventSubscriptionQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_Count_Call) Return(n int64, err error) *MockEventSubscriptionQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockEventSubscriptionQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) Create(ctx context.Context, entity *EventSubscription) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *EventSubscription) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventSubscriptionQuerier_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockEventSubscriptionQuerier_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *EventSubscription
func (_e *MockEventSubscriptionQuerier_Expecter) Create(ctx interface{}, entity interface{}) *MockEventSubscriptionQuerier_Create_Call {
	return &MockEventSubscriptionQuerier_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockEventSubscriptionQuerier_Create_Call) Run(run func(ctx context.Context, entity *EventSubscription)) *MockEventSubscriptionQuerier_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *EventSubscription
		if args[1] != nil {
			arg1 = args[1].(*EventSubscription)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_Create_Call) Return(err error) *MockEventSubscriptionQuerier_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_Create_Call) RunAndReturn(run func(ctx context.Context, entity *EventSubscription) error) *MockEventSubscriptionQuerier_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventSubscriptionQuerier_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockEventSubscriptionQuerier_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventSubscriptionQuerier_Expecter) Delete(ctx interface{}, id interface{}) *MockEventSubscriptionQuerier_Delete_Call {
	return &MockEventSubscriptionQuerier_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockEventSubscriptionQuerier_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventSubscriptionQuerier_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_Delete_Call) Return(err error) *MockEventSubscriptionQuerier_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockEventSubscriptionQuerier_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockEventSubscriptionQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventSubscriptionQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockEventSubscriptionQuerier_Exists_Call {
	return &MockEventSubscriptionQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockEventSubscriptionQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventSubscriptionQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_Exists_Call) Return(b bool, err error) *MockEventSubscriptionQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockEventSubscriptionQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsBySubscriberID provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) ExistsBySubscriberID(ctx context.Context, subscriberID string) (bool, error) {
	ret := _mock.Called(ctx, subscriberID)

	if len(ret) == 0 {
		panic("no return value specified for ExistsBySubscriberID")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, subscriberID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, subscriberID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, subscriberID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionQuerier_ExistsBySubscriberID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsBySubscriberID'
type MockEventSubscriptionQuerier_ExistsBySubscriberID_Call struct {
	*mock.Call
}

// ExistsBySubscriberID is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
func (_e *MockEventSubscriptionQuerier_Expecter) ExistsBySubscriberID(ctx interface{}, subscriberID interface{}) *MockEventSubscriptionQuerier_ExistsBySubscriberID_Call {
	return &MockEventSubscriptionQuerier_ExistsBySubscriberID_Call{Call: _e.mock.On("ExistsBySubscriberID", ctx, subscriberID)}
}

func (_c *MockEventSubscriptionQuerier_ExistsBySubscriberID_Call) Run(run func(ctx context.Context, subscriberID string)) *MockEventSubscriptionQuerier_ExistsBySubscriberID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_ExistsBySubscriberID_Call) Return(b bool, err error) *MockEventSubscriptionQuerier_ExistsBySubscriberID_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_ExistsBySubscriberID_Call) RunAndReturn(run func(ctx context.Context, subscriberID string) (bool, error)) *MockEventSubscriptionQuerier_ExistsBySubscriberID_Call {
	_c.Call.Return(run)
	return _c
}

// FindBySubscriberID provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) FindBySubscriberID(ctx context.Context, subscriberID string) (*EventSubscription, error) {
	ret := _mock.Called(ctx, subscriberID)

	if len(ret) == 0 {
		panic("no return value specified for FindBySubscriberID")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*EventSubscription, error)); ok {
		return returnFunc(ctx, subscriberID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *EventSubscription); ok {
		r0 = returnFunc(ctx, subscriberID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, subscriberID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionQuerier_FindBySubscriberID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBySubscriberID'
type MockEventSubscriptionQuerier_FindBySubscriberID_Call struct {
	*mock.Call
}

// FindBySubscriberID is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriberID string
func (_e *MockEventSubscriptionQuerier_Expecter) FindBySubscriberID(ctx interface{}, subscriberID interface{}) *MockEventSubscriptionQuerier_FindBySubscriberID_Call {
	return &MockEventSubscriptionQuerier_FindBySubscriberID_Call{Call: _e.mock.On("FindBySubscriberID", ctx, subscriberID)}
}

func (_c *MockEventSubscriptionQuerier_FindBySubscriberID_Call) Run(run func(ctx context.Context, subscriberID string)) *MockEventSubscriptionQuerier_FindBySubscriberID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_FindBySubscriberID_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionQuerier_FindBySubscriberID_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_FindBySubscriberID_Call) RunAndReturn(run func(ctx context.Context, subscriberID string) (*EventSubscription, error)) *MockEventSubscriptionQuerier_FindBySubscriberID_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) Get(ctx context.Context, id properties.UUID) (*EventSubscription, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*EventSubscription, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *EventSubscription); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockEventSubscriptionQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockEventSubscriptionQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockEventSubscriptionQuerier_Get_Call {
	return &MockEventSubscriptionQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockEventSubscriptionQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockEventSubscriptionQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_Get_Call) Return(eventSubscription *EventSubscription, err error) *MockEventSubscriptionQuerier_Get_Call {
	_c.Call.Return(eventSubscription, err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*EventSubscription, error)) *MockEventSubscriptionQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[EventSubscription], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[EventSubscription]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[EventSubscription], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[EventSubscription]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[EventSubscription])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockEventSubscriptionQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockEventSubscriptionQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockEventSubscriptionQuerier_List_Call {
	return &MockEventSubscriptionQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockEventSubscriptionQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockEventSubscriptionQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_List_Call) Return(pageRes *PageRes[EventSubscription], err error) *MockEventSubscriptionQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[EventSubscription], error)) *MockEventSubscriptionQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListExpiredLeases provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) ListExpiredLeases(ctx context.Context) ([]*EventSubscription, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListExpiredLeases")
	}

	var r0 []*EventSubscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*EventSubscription, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*EventSubscription); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*EventSubscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEventSubscriptionQuerier_ListExpiredLeases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExpiredLeases'
type MockEventSubscriptionQuerier_ListExpiredLeases_Call struct {
	*mock.Call
}

// ListExpiredLeases is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEventSubscriptionQuerier_Expecter) ListExpiredLeases(ctx interface{}) *MockEventSubscriptionQuerier_ListExpiredLeases_Call {
	return &MockEventSubscriptionQuerier_ListExpiredLeases_Call{Call: _e.mock.On("ListExpiredLeases", ctx)}
}

func (_c *MockEventSubscriptionQuerier_ListExpiredLeases_Call) Run(run func(ctx context.Context)) *MockEventSubscriptionQuerier_ListExpiredLeases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_ListExpiredLeases_Call) Return(eventSubscriptions []*EventSubscription, err error) *MockEventSubscriptionQuerier_ListExpiredLeases_Call {
	_c.Call.Return(eventSubscriptions, err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_ListExpiredLeases_Call) RunAndReturn(run func(ctx context.Context) ([]*EventSubscription, error)) *MockEventSubscriptionQuerier_ListExpiredLeases_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockEventSubscriptionQuerier
func (_mock *MockEventSubscriptionQuerier) Save(ctx context.Context, entity *EventSubscription) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *EventSubscription) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventSubscriptionQuerier_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockEventSubscriptionQuerier_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *EventSubscription
func (_e *MockEventSubscriptionQuerier_Expecter) Save(ctx interface{}, entity interface{}) *MockEventSubscriptionQuerier_Save_Call {
	return &MockEventSubscriptionQuerier_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockEventSubscriptionQuerier_Save_Call) Run(run func(ctx context.Context, entity *EventSubscription)) *MockEventSubscriptionQuerier_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *EventSubscription
		if args[1] != nil {
			arg1 = args[1].(*EventSubscription)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventSubscriptionQuerier_Save_Call) Return(err error) *MockEventSubscriptionQuerier_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventSubscriptionQuerier_Save_Call) RunAndReturn(run func(ctx context.Context, entity *EventSubscription) error) *MockEventSubscriptionQuerier_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockJobCommander creates a new instance of MockJobCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockJobCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockJobCommander {
	mock := &MockJobCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockJobCommander is an autogenerated mock type for the JobCommander type
type MockJobCommander struct {
	mock.Mock
}

type MockJobCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockJobCommander) EXPECT() *MockJobCommander_Expecter {
	return &MockJobCommander_Expecter{mock: &_m.Mock}
}

// Claim provides a mock function for the type MockJobCommander
func (_mock *MockJobCommander) Claim(ctx context.Context, jobID properties.UUID) error {
	ret := _mock.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for Claim")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, jobID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockJobCommander_Claim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Claim'
type MockJobCommander_Claim_Call struct {
	*mock.Call
}

// Claim is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID properties.UUID
func (_e *MockJobCommander_Expecter) Claim(ctx interface{}, jobID interface{}) *MockJobCommander_Claim_Call {
	return &MockJobCommander_Claim_Call{Call: _e.mock.On("Claim", ctx, jobID)}
}

func (_c *MockJobCommander_Claim_Call) Run(run func(ctx context.Context, jobID properties.UUID)) *MockJobCommander_Claim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobCommander_Claim_Call) Return(err error) *MockJobCommander_Claim_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockJobCommander_Claim_Call) RunAndReturn(run func(ctx context.Context, jobID properties.UUID) error) *MockJobCommander_Claim_Call {
	_c.Call.Return(run)
	return _c
}

// Complete provides a mock function for the type MockJobCommander
func (_mock *MockJobCommander) Complete(ctx context.Context, jobID properties.UUID, resources *properties.JSON, externalID *string) error {
	ret := _mock.Called(ctx, jobID, resources, externalID)

	if len(ret) == 0 {
		panic("no return value specified for Complete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *properties.JSON, *string) error); ok {
		r0 = returnFunc(ctx, jobID, resources, externalID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockJobCommander_Complete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Complete'
type MockJobCommander_Complete_Call struct {
	*mock.Call
}

// Complete is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID properties.UUID
//   - resources *properties.JSON
//   - externalID *string
func (_e *MockJobCommander_Expecter) Complete(ctx interface{}, jobID interface{}, resources interface{}, externalID interface{}) *MockJobCommander_Complete_Call {
	return &MockJobCommander_Complete_Call{Call: _e.mock.On("Complete", ctx, jobID, resources, externalID)}
}

func (_c *MockJobCommander_Complete_Call) Run(run func(ctx context.Context, jobID properties.UUID, resources *properties.JSON, externalID *string)) *MockJobCommander_Complete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 *properties.JSON
		if args[2] != nil {
			arg2 = args[2].(*properties.JSON)
		}
		var arg3 *string
		if args[3] != nil {
			arg3 = args[3].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockJobCommander_Complete_Call) Return(err error) *MockJobCommander_Complete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockJobCommander_Complete_Call) RunAndReturn(run func(ctx context.Context, jobID properties.UUID, resources *properties.JSON, externalID *string) error) *MockJobCommander_Complete_Call {
	_c.Call.Return(run)
	return _c
}

// Fail provides a mock function for the type MockJobCommander
func (_mock *MockJobCommander) Fail(ctx context.Context, jobID properties.UUID, errorMessage string) error {
	ret := _mock.Called(ctx, jobID, errorMessage)

	if len(ret) == 0 {
		panic("no return value specified for Fail")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, string) error); ok {
		r0 = returnFunc(ctx, jobID, errorMessage)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockJobCommander_Fail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fail'
type MockJobCommander_Fail_Call struct {
	*mock.Call
}

// Fail is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID properties.UUID
//   - errorMessage string
func (_e *MockJobCommander_Expecter) Fail(ctx interface{}, jobID interface{}, errorMessage interface{}) *MockJobCommander_Fail_Call {
	return &MockJobCommander_Fail_Call{Call: _e.mock.On("Fail", ctx, jobID, errorMessage)}
}

func (_c *MockJobCommander_Fail_Call) Run(run func(ctx context.Context, jobID properties.UUID, errorMessage string)) *MockJobCommander_Fail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockJobCommander_Fail_Call) Return(err error) *MockJobCommander_Fail_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockJobCommander_Fail_Call) RunAndReturn(run func(ctx context.Context, jobID properties.UUID, errorMessage string) error) *MockJobCommander_Fail_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockJobRepository creates a new instance of MockJobRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockJobRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockJobRepository {
	mock := &MockJobRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockJobRepository is an autogenerated mock type for the JobRepository type
type MockJobRepository struct {
	mock.Mock
}

type MockJobRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockJobRepository) EXPECT() *MockJobRepository_Expecter {
	return &MockJobRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockJobRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockJobRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockJobRepository_AuthScope_Call {
	return &MockJobRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockJobRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockJobRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockJobRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockJobRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockJobRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockJobRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockJobRepository_Expecter) Count(ctx interface{}) *MockJobRepository_Count_Call {
	return &MockJobRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockJobRepository_Count_Call) Run(run func(ctx context.Context)) *MockJobRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockJobRepository_Count_Call) Return(n int64, err error) *MockJobRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockJobRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockJobRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) Create(ctx context.Context, entity *Job) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Job) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockJobRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockJobRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Job
func (_e *MockJobRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockJobRepository_Create_Call {
	return &MockJobRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockJobRepository_Create_Call) Run(run func(ctx context.Context, entity *Job)) *MockJobRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Job
		if args[1] != nil {
			arg1 = args[1].(*Job)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobRepository_Create_Call) Return(err error) *MockJobRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockJobRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *Job) error) *MockJobRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockJobRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockJobRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockJobRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockJobRepository_Delete_Call {
	return &MockJobRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockJobRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockJobRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobRepository_Delete_Call) Return(err error) *MockJobRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockJobRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockJobRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteOldCompletedJobs provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) DeleteOldCompletedJobs(ctx context.Context, olderThan time.Duration) (int, error) {
	ret := _mock.Called(ctx, olderThan)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOldCompletedJobs")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) (int, error)); ok {
		return returnFunc(ctx, olderThan)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) int); ok {
		r0 = returnFunc(ctx, olderThan)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = returnFunc(ctx, olderThan)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobRepository_DeleteOldCompletedJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteOldCompletedJobs'
type MockJobRepository_DeleteOldCompletedJobs_Call struct {
	*mock.Call
}

// DeleteOldCompletedJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - olderThan time.Duration
func (_e *MockJobRepository_Expecter) DeleteOldCompletedJobs(ctx interface{}, olderThan interface{}) *MockJobRepository_DeleteOldCompletedJobs_Call {
	return &MockJobRepository_DeleteOldCompletedJobs_Call{Call: _e.mock.On("DeleteOldCompletedJobs", ctx, olderThan)}
}

func (_c *MockJobRepository_DeleteOldCompletedJobs_Call) Run(run func(ctx context.Context, olderThan time.Duration)) *MockJobRepository_DeleteOldCompletedJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobRepository_DeleteOldCompletedJobs_Call) Return(n int, err error) *MockJobRepository_DeleteOldCompletedJobs_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockJobRepository_DeleteOldCompletedJobs_Call) RunAndReturn(run func(ctx context.Context, olderThan time.Duration) (int, error)) *MockJobRepository_DeleteOldCompletedJobs_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockJobRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockJobRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockJobRepository_Exists_Call {
	return &MockJobRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockJobRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockJobRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobRepository_Exists_Call) Return(b bool, err error) *MockJobRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockJobRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockJobRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) Get(ctx context.Context, id properties.UUID) (*Job, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Job, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Job); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockJobRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockJobRepository_Expecter) Get(ctx interface{}, id interface{}) *MockJobRepository_Get_Call {
	return &MockJobRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockJobRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockJobRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobRepository_Get_Call) Return(job *Job, err error) *MockJobRepository_Get_Call {
	_c.Call.Return(job, err)
	return _c
}

func (_c *MockJobRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Job, error)) *MockJobRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetPendingJobsForAgent provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) GetPendingJobsForAgent(ctx context.Context, agentID properties.UUID, limit int) ([]*Job, error) {
	ret := _mock.Called(ctx, agentID, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingJobsForAgent")
	}

	var r0 []*Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, int) ([]*Job, error)); ok {
		return returnFunc(ctx, agentID, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, int) []*Job); ok {
		r0 = returnFunc(ctx, agentID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, int) error); ok {
		r1 = returnFunc(ctx, agentID, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobRepository_GetPendingJobsForAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPendingJobsForAgent'
type MockJobRepository_GetPendingJobsForAgent_Call struct {
	*mock.Call
}

// GetPendingJobsForAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID properties.UUID
//   - limit int
func (_e *MockJobRepository_Expecter) GetPendingJobsForAgent(ctx interface{}, agentID interface{}, limit interface{}) *MockJobRepository_GetPendingJobsForAgent_Call {
	return &MockJobRepository_GetPendingJobsForAgent_Call{Call: _e.mock.On("GetPendingJobsForAgent", ctx, agentID, limit)}
}

func (_c *MockJobRepository_GetPendingJobsForAgent_Call) Run(run func(ctx context.Context, agentID properties.UUID, limit int)) *MockJobRepository_GetPendingJobsForAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockJobRepository_GetPendingJobsForAgent_Call) Return(jobs []*Job, err error) *MockJobRepository_GetPendingJobsForAgent_Call {
	_c.Call.Return(jobs, err)
	return _c
}

func (_c *MockJobRepository_GetPendingJobsForAgent_Call) RunAndReturn(run func(ctx context.Context, agentID properties.UUID, limit int) ([]*Job, error)) *MockJobRepository_GetPendingJobsForAgent_Call {
	_c.Call.Return(run)
	return _c
}

// GetTimeOutJobs provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) GetTimeOutJobs(ctx context.Context, olderThan time.Duration) ([]*Job, error) {
	ret := _mock.Called(ctx, olderThan)

	if len(ret) == 0 {
		panic("no return value specified for GetTimeOutJobs")
	}

	var r0 []*Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) ([]*Job, error)); ok {
		return returnFunc(ctx, olderThan)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) []*Job); ok {
		r0 = returnFunc(ctx, olderThan)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = returnFunc(ctx, olderThan)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobRepository_GetTimeOutJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTimeOutJobs'
type MockJobRepository_GetTimeOutJobs_Call struct {
	*mock.Call
}

// GetTimeOutJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - olderThan time.Duration
func (_e *MockJobRepository_Expecter) GetTimeOutJobs(ctx interface{}, olderThan interface{}) *MockJobRepository_GetTimeOutJobs_Call {
	return &MockJobRepository_GetTimeOutJobs_Call{Call: _e.mock.On("GetTimeOutJobs", ctx, olderThan)}
}

func (_c *MockJobRepository_GetTimeOutJobs_Call) Run(run func(ctx context.Context, olderThan time.Duration)) *MockJobRepository_GetTimeOutJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobRepository_GetTimeOutJobs_Call) Return(jobs []*Job, err error) *MockJobRepository_GetTimeOutJobs_Call {
	_c.Call.Return(jobs, err)
	return _c
}

func (_c *MockJobRepository_GetTimeOutJobs_Call) RunAndReturn(run func(ctx context.Context, olderThan time.Duration) ([]*Job, error)) *MockJobRepository_GetTimeOutJobs_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Job], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Job]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Job], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Job]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Job])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockJobRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockJobRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockJobRepository_List_Call {
	return &MockJobRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockJobRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockJobRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockJobRepository_List_Call) Return(pageRes *PageRes[Job], err error) *MockJobRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockJobRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Job], error)) *MockJobRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockJobRepository
func (_mock *MockJobRepository) Save(ctx context.Context, entity *Job) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Job) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockJobRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockJobRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Job
func (_e *MockJobRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockJobRepository_Save_Call {
	return &MockJobRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockJobRepository_Save_Call) Run(run func(ctx context.Context, entity *Job)) *MockJobRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Job
		if args[1] != nil {
			arg1 = args[1].(*Job)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobRepository_Save_Call) Return(err error) *MockJobRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockJobRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *Job) error) *MockJobRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockJobQuerier creates a new instance of MockJobQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockJobQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockJobQuerier {
	mock := &MockJobQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockJobQuerier is an autogenerated mock type for the JobQuerier type
type MockJobQuerier struct {
	mock.Mock
}

type MockJobQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockJobQuerier) EXPECT() *MockJobQuerier_Expecter {
	return &MockJobQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockJobQuerier
func (_mock *MockJobQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockJobQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockJobQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockJobQuerier_AuthScope_Call {
	return &MockJobQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockJobQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockJobQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockJobQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockJobQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockJobQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockJobQuerier
func (_mock *MockJobQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockJobQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockJobQuerier_Expecter) Count(ctx interface{}) *MockJobQuerier_Count_Call {
	return &MockJobQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockJobQuerier_Count_Call) Run(run func(ctx context.Context)) *MockJobQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockJobQuerier_Count_Call) Return(n int64, err error) *MockJobQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockJobQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockJobQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockJobQuerier
func (_mock *MockJobQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockJobQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockJobQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockJobQuerier_Exists_Call {
	return &MockJobQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockJobQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockJobQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobQuerier_Exists_Call) Return(b bool, err error) *MockJobQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockJobQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockJobQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockJobQuerier
func (_mock *MockJobQuerier) Get(ctx context.Context, id properties.UUID) (*Job, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Job, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Job); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockJobQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockJobQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockJobQuerier_Get_Call {
	return &MockJobQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockJobQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockJobQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobQuerier_Get_Call) Return(job *Job, err error) *MockJobQuerier_Get_Call {
	_c.Call.Return(job, err)
	return _c
}

func (_c *MockJobQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Job, error)) *MockJobQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetPendingJobsForAgent provides a mock function for the type MockJobQuerier
func (_mock *MockJobQuerier) GetPendingJobsForAgent(ctx context.Context, agentID properties.UUID, limit int) ([]*Job, error) {
	ret := _mock.Called(ctx, agentID, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingJobsForAgent")
	}

	var r0 []*Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, int) ([]*Job, error)); ok {
		return returnFunc(ctx, agentID, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, int) []*Job); ok {
		r0 = returnFunc(ctx, agentID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, int) error); ok {
		r1 = returnFunc(ctx, agentID, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobQuerier_GetPendingJobsForAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPendingJobsForAgent'
type MockJobQuerier_GetPendingJobsForAgent_Call struct {
	*mock.Call
}

// GetPendingJobsForAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID properties.UUID
//   - limit int
func (_e *MockJobQuerier_Expecter) GetPendingJobsForAgent(ctx interface{}, agentID interface{}, limit interface{}) *MockJobQuerier_GetPendingJobsForAgent_Call {
	return &MockJobQuerier_GetPendingJobsForAgent_Call{Call: _e.mock.On("GetPendingJobsForAgent", ctx, agentID, limit)}
}

func (_c *MockJobQuerier_GetPendingJobsForAgent_Call) Run(run func(ctx context.Context, agentID properties.UUID, limit int)) *MockJobQuerier_GetPendingJobsForAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockJobQuerier_GetPendingJobsForAgent_Call) Return(jobs []*Job, err error) *MockJobQuerier_GetPendingJobsForAgent_Call {
	_c.Call.Return(jobs, err)
	return _c
}

func (_c *MockJobQuerier_GetPendingJobsForAgent_Call) RunAndReturn(run func(ctx context.Context, agentID properties.UUID, limit int) ([]*Job, error)) *MockJobQuerier_GetPendingJobsForAgent_Call {
	_c.Call.Return(run)
	return _c
}

// GetTimeOutJobs provides a mock function for the type MockJobQuerier
func (_mock *MockJobQuerier) GetTimeOutJobs(ctx context.Context, olderThan time.Duration) ([]*Job, error) {
	ret := _mock.Called(ctx, olderThan)

	if len(ret) == 0 {
		panic("no return value specified for GetTimeOutJobs")
	}

	var r0 []*Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) ([]*Job, error)); ok {
		return returnFunc(ctx, olderThan)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) []*Job); ok {
		r0 = returnFunc(ctx, olderThan)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = returnFunc(ctx, olderThan)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobQuerier_GetTimeOutJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTimeOutJobs'
type MockJobQuerier_GetTimeOutJobs_Call struct {
	*mock.Call
}

// GetTimeOutJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - olderThan time.Duration
func (_e *MockJobQuerier_Expecter) GetTimeOutJobs(ctx interface{}, olderThan interface{}) *MockJobQuerier_GetTimeOutJobs_Call {
	return &MockJobQuerier_GetTimeOutJobs_Call{Call: _e.mock.On("GetTimeOutJobs", ctx, olderThan)}
}

func (_c *MockJobQuerier_GetTimeOutJobs_Call) Run(run func(ctx context.Context, olderThan time.Duration)) *MockJobQuerier_GetTimeOutJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJobQuerier_GetTimeOutJobs_Call) Return(jobs []*Job, err error) *MockJobQuerier_GetTimeOutJobs_Call {
	_c.Call.Return(jobs, err)
	return _c
}

func (_c *MockJobQuerier_GetTimeOutJobs_Call) RunAndReturn(run func(ctx context.Context, olderThan time.Duration) ([]*Job, error)) *MockJobQuerier_GetTimeOutJobs_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockJobQuerier
func (_mock *MockJobQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Job], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Job]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Job], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Job]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Job])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJobQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockJobQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockJobQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockJobQuerier_List_Call {
	return &MockJobQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockJobQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockJobQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockJobQuerier_List_Call) Return(pageRes *PageRes[Job], err error) *MockJobQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockJobQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Job], error)) *MockJobQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetricEntryCommander creates a new instance of MockMetricEntryCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetricEntryCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetricEntryCommander {
	mock := &MockMetricEntryCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetricEntryCommander is an autogenerated mock type for the MetricEntryCommander type
type MockMetricEntryCommander struct {
	mock.Mock
}

type MockMetricEntryCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetricEntryCommander) EXPECT() *MockMetricEntryCommander_Expecter {
	return &MockMetricEntryCommander_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockMetricEntryCommander
func (_mock *MockMetricEntryCommander) Create(ctx context.Context, typeName string, agentID properties.UUID, serviceID properties.UUID, resourceID string, value float64) (*MetricEntry, error) {
	ret := _mock.Called(ctx, typeName, agentID, serviceID, resourceID, value)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *MetricEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, properties.UUID, properties.UUID, string, float64) (*MetricEntry, error)); ok {
		return returnFunc(ctx, typeName, agentID, serviceID, resourceID, value)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, properties.UUID, properties.UUID, string, float64) *MetricEntry); ok {
		r0 = returnFunc(ctx, typeName, agentID, serviceID, resourceID, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, properties.UUID, properties.UUID, string, float64) error); ok {
		r1 = returnFunc(ctx, typeName, agentID, serviceID, resourceID, value)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryCommander_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockMetricEntryCommander_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - typeName string
//   - agentID properties.UUID
//   - serviceID properties.UUID
//   - resourceID string
//   - value float64
func (_e *MockMetricEntryCommander_Expecter) Create(ctx interface{}, typeName interface{}, agentID interface{}, serviceID interface{}, resourceID interface{}, value interface{}) *MockMetricEntryCommander_Create_Call {
	return &MockMetricEntryCommander_Create_Call{Call: _e.mock.On("Create", ctx, typeName, agentID, serviceID, resourceID, value)}
}

func (_c *MockMetricEntryCommander_Create_Call) Run(run func(ctx context.Context, typeName string, agentID properties.UUID, serviceID properties.UUID, resourceID string, value float64)) *MockMetricEntryCommander_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 properties.UUID
		if args[2] != nil {
			arg2 = args[2].(properties.UUID)
		}
		var arg3 properties.UUID
		if args[3] != nil {
			arg3 = args[3].(properties.UUID)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 float64
		if args[5] != nil {
			arg5 = args[5].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockMetricEntryCommander_Create_Call) Return(metricEntry *MetricEntry, err error) *MockMetricEntryCommander_Create_Call {
	_c.Call.Return(metricEntry, err)
	return _c
}

func (_c *MockMetricEntryCommander_Create_Call) RunAndReturn(run func(ctx context.Context, typeName string, agentID properties.UUID, serviceID properties.UUID, resourceID string, value float64) (*MetricEntry, error)) *MockMetricEntryCommander_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWithExternalID provides a mock function for the type MockMetricEntryCommander
func (_mock *MockMetricEntryCommander) CreateWithExternalID(ctx context.Context, typeName string, agentID properties.UUID, externalID string, resourceID string, value float64) (*MetricEntry, error) {
	ret := _mock.Called(ctx, typeName, agentID, externalID, resourceID, value)

	if len(ret) == 0 {
		panic("no return value specified for CreateWithExternalID")
	}

	var r0 *MetricEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, properties.UUID, string, string, float64) (*MetricEntry, error)); ok {
		return returnFunc(ctx, typeName, agentID, externalID, resourceID, value)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, properties.UUID, string, string, float64) *MetricEntry); ok {
		r0 = returnFunc(ctx, typeName, agentID, externalID, resourceID, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, properties.UUID, string, string, float64) error); ok {
		r1 = returnFunc(ctx, typeName, agentID, externalID, resourceID, value)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryCommander_CreateWithExternalID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWithExternalID'
type MockMetricEntryCommander_CreateWithExternalID_Call struct {
	*mock.Call
}

// CreateWithExternalID is a helper method to define mock.On call
//   - ctx context.Context
//   - typeName string
//   - agentID properties.UUID
//   - externalID string
//   - resourceID string
//   - value float64
func (_e *MockMetricEntryCommander_Expecter) CreateWithExternalID(ctx interface{}, typeName interface{}, agentID interface{}, externalID interface{}, resourceID interface{}, value interface{}) *MockMetricEntryCommander_CreateWithExternalID_Call {
	return &MockMetricEntryCommander_CreateWithExternalID_Call{Call: _e.mock.On("CreateWithExternalID", ctx, typeName, agentID, externalID, resourceID, value)}
}

func (_c *MockMetricEntryCommander_CreateWithExternalID_Call) Run(run func(ctx context.Context, typeName string, agentID properties.UUID, externalID string, resourceID string, value float64)) *MockMetricEntryCommander_CreateWithExternalID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 properties.UUID
		if args[2] != nil {
			arg2 = args[2].(properties.UUID)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 float64
		if args[5] != nil {
			arg5 = args[5].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockMetricEntryCommander_CreateWithExternalID_Call) Return(metricEntry *MetricEntry, err error) *MockMetricEntryCommander_CreateWithExternalID_Call {
	_c.Call.Return(metricEntry, err)
	return _c
}

func (_c *MockMetricEntryCommander_CreateWithExternalID_Call) RunAndReturn(run func(ctx context.Context, typeName string, agentID properties.UUID, externalID string, resourceID string, value float64) (*MetricEntry, error)) *MockMetricEntryCommander_CreateWithExternalID_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetricEntryRepository creates a new instance of MockMetricEntryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetricEntryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetricEntryRepository {
	mock := &MockMetricEntryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetricEntryRepository is an autogenerated mock type for the MetricEntryRepository type
type MockMetricEntryRepository struct {
	mock.Mock
}

type MockMetricEntryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetricEntryRepository) EXPECT() *MockMetricEntryRepository_Expecter {
	return &MockMetricEntryRepository_Expecter{mock: &_m.Mock}
}

// Aggregate provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) Aggregate(ctx context.Context, aggregateType AggregateType, serviceID properties.UUID, typeID properties.UUID, start time.Time, end time.Time) (float64, error) {
	ret := _mock.Called(ctx, aggregateType, serviceID, typeID, start, end)

	if len(ret) == 0 {
		panic("no return value specified for Aggregate")
	}

	var r0 float64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, AggregateType, properties.UUID, properties.UUID, time.Time, time.Time) (float64, error)); ok {
		return returnFunc(ctx, aggregateType, serviceID, typeID, start, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, AggregateType, properties.UUID, properties.UUID, time.Time, time.Time) float64); ok {
		r0 = returnFunc(ctx, aggregateType, serviceID, typeID, start, end)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, AggregateType, properties.UUID, properties.UUID, time.Time, time.Time) error); ok {
		r1 = returnFunc(ctx, aggregateType, serviceID, typeID, start, end)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryRepository_Aggregate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Aggregate'
type MockMetricEntryRepository_Aggregate_Call struct {
	*mock.Call
}

// Aggregate is a helper method to define mock.On call
//   - ctx context.Context
//   - aggregateType AggregateType
//   - serviceID properties.UUID
//   - typeID properties.UUID
//   - start time.Time
//   - end time.Time
func (_e *MockMetricEntryRepository_Expecter) Aggregate(ctx interface{}, aggregateType interface{}, serviceID interface{}, typeID interface{}, start interface{}, end interface{}) *MockMetricEntryRepository_Aggregate_Call {
	return &MockMetricEntryRepository_Aggregate_Call{Call: _e.mock.On("Aggregate", ctx, aggregateType, serviceID, typeID, start, end)}
}

func (_c *MockMetricEntryRepository_Aggregate_Call) Run(run func(ctx context.Context, aggregateType AggregateType, serviceID properties.UUID, typeID properties.UUID, start time.Time, end time.Time)) *MockMetricEntryRepository_Aggregate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 AggregateType
		if args[1] != nil {
			arg1 = args[1].(AggregateType)
		}
		var arg2 properties.UUID
		if args[2] != nil {
			arg2 = args[2].(properties.UUID)
		}
		var arg3 properties.UUID
		if args[3] != nil {
			arg3 = args[3].(properties.UUID)
		}
		var arg4 time.Time
		if args[4] != nil {
			arg4 = args[4].(time.Time)
		}
		var arg5 time.Time
		if args[5] != nil {
			arg5 = args[5].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_Aggregate_Call) Return(f float64, err error) *MockMetricEntryRepository_Aggregate_Call {
	_c.Call.Return(f, err)
	return _c
}

func (_c *MockMetricEntryRepository_Aggregate_Call) RunAndReturn(run func(ctx context.Context, aggregateType AggregateType, serviceID properties.UUID, typeID properties.UUID, start time.Time, end time.Time) (float64, error)) *MockMetricEntryRepository_Aggregate_Call {
	_c.Call.Return(run)
	return _c
}

// AuthScope provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockMetricEntryRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricEntryRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockMetricEntryRepository_AuthScope_Call {
	return &MockMetricEntryRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockMetricEntryRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricEntryRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockMetricEntryRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockMetricEntryRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockMetricEntryRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockMetricEntryRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMetricEntryRepository_Expecter) Count(ctx interface{}) *MockMetricEntryRepository_Count_Call {
	return &MockMetricEntryRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockMetricEntryRepository_Count_Call) Run(run func(ctx context.Context)) *MockMetricEntryRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_Count_Call) Return(n int64, err error) *MockMetricEntryRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMetricEntryRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockMetricEntryRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CountByMetricType provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) CountByMetricType(ctx context.Context, typeID properties.UUID) (int64, error) {
	ret := _mock.Called(ctx, typeID)

	if len(ret) == 0 {
		panic("no return value specified for CountByMetricType")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (int64, error)); ok {
		return returnFunc(ctx, typeID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) int64); ok {
		r0 = returnFunc(ctx, typeID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, typeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryRepository_CountByMetricType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByMetricType'
type MockMetricEntryRepository_CountByMetricType_Call struct {
	*mock.Call
}

// CountByMetricType is a helper method to define mock.On call
//   - ctx context.Context
//   - typeID properties.UUID
func (_e *MockMetricEntryRepository_Expecter) CountByMetricType(ctx interface{}, typeID interface{}) *MockMetricEntryRepository_CountByMetricType_Call {
	return &MockMetricEntryRepository_CountByMetricType_Call{Call: _e.mock.On("CountByMetricType", ctx, typeID)}
}

func (_c *MockMetricEntryRepository_CountByMetricType_Call) Run(run func(ctx context.Context, typeID properties.UUID)) *MockMetricEntryRepository_CountByMetricType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_CountByMetricType_Call) Return(n int64, err error) *MockMetricEntryRepository_CountByMetricType_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMetricEntryRepository_CountByMetricType_Call) RunAndReturn(run func(ctx context.Context, typeID properties.UUID) (int64, error)) *MockMetricEntryRepository_CountByMetricType_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) Create(ctx context.Context, entity *MetricEntry) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *MetricEntry) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMetricEntryRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockMetricEntryRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *MetricEntry
func (_e *MockMetricEntryRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockMetricEntryRepository_Create_Call {
	return &MockMetricEntryRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockMetricEntryRepository_Create_Call) Run(run func(ctx context.Context, entity *MetricEntry)) *MockMetricEntryRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *MetricEntry
		if args[1] != nil {
			arg1 = args[1].(*MetricEntry)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_Create_Call) Return(err error) *MockMetricEntryRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMetricEntryRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *MetricEntry) error) *MockMetricEntryRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMetricEntryRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockMetricEntryRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricEntryRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockMetricEntryRepository_Delete_Call {
	return &MockMetricEntryRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockMetricEntryRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricEntryRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_Delete_Call) Return(err error) *MockMetricEntryRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMetricEntryRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockMetricEntryRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockMetricEntryRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricEntryRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockMetricEntryRepository_Exists_Call {
	return &MockMetricEntryRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockMetricEntryRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricEntryRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_Exists_Call) Return(b bool, err error) *MockMetricEntryRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockMetricEntryRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockMetricEntryRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) Get(ctx context.Context, id properties.UUID) (*MetricEntry, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *MetricEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*MetricEntry, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *MetricEntry); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockMetricEntryRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricEntryRepository_Expecter) Get(ctx interface{}, id interface{}) *MockMetricEntryRepository_Get_Call {
	return &MockMetricEntryRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockMetricEntryRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricEntryRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_Get_Call) Return(metricEntry *MetricEntry, err error) *MockMetricEntryRepository_Get_Call {
	_c.Call.Return(metricEntry, err)
	return _c
}

func (_c *MockMetricEntryRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*MetricEntry, error)) *MockMetricEntryRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[MetricEntry], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[MetricEntry]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[MetricEntry], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[MetricEntry]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[MetricEntry])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockMetricEntryRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockMetricEntryRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockMetricEntryRepository_List_Call {
	return &MockMetricEntryRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockMetricEntryRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockMetricEntryRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_List_Call) Return(pageRes *PageRes[MetricEntry], err error) *MockMetricEntryRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockMetricEntryRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[MetricEntry], error)) *MockMetricEntryRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockMetricEntryRepository
func (_mock *MockMetricEntryRepository) Save(ctx context.Context, entity *MetricEntry) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *MetricEntry) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMetricEntryRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockMetricEntryRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *MetricEntry
func (_e *MockMetricEntryRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockMetricEntryRepository_Save_Call {
	return &MockMetricEntryRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockMetricEntryRepository_Save_Call) Run(run func(ctx context.Context, entity *MetricEntry)) *MockMetricEntryRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *MetricEntry
		if args[1] != nil {
			arg1 = args[1].(*MetricEntry)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryRepository_Save_Call) Return(err error) *MockMetricEntryRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMetricEntryRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *MetricEntry) error) *MockMetricEntryRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetricEntryQuerier creates a new instance of MockMetricEntryQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetricEntryQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetricEntryQuerier {
	mock := &MockMetricEntryQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetricEntryQuerier is an autogenerated mock type for the MetricEntryQuerier type
type MockMetricEntryQuerier struct {
	mock.Mock
}

type MockMetricEntryQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetricEntryQuerier) EXPECT() *MockMetricEntryQuerier_Expecter {
	return &MockMetricEntryQuerier_Expecter{mock: &_m.Mock}
}

// Aggregate provides a mock function for the type MockMetricEntryQuerier
func (_mock *MockMetricEntryQuerier) Aggregate(ctx context.Context, aggregateType AggregateType, serviceID properties.UUID, typeID properties.UUID, start time.Time, end time.Time) (float64, error) {
	ret := _mock.Called(ctx, aggregateType, serviceID, typeID, start, end)

	if len(ret) == 0 {
		panic("no return value specified for Aggregate")
	}

	var r0 float64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, AggregateType, properties.UUID, properties.UUID, time.Time, time.Time) (float64, error)); ok {
		return returnFunc(ctx, aggregateType, serviceID, typeID, start, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, AggregateType, properties.UUID, properties.UUID, time.Time, time.Time) float64); ok {
		r0 = returnFunc(ctx, aggregateType, serviceID, typeID, start, end)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, AggregateType, properties.UUID, properties.UUID, time.Time, time.Time) error); ok {
		r1 = returnFunc(ctx, aggregateType, serviceID, typeID, start, end)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryQuerier_Aggregate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Aggregate'
type MockMetricEntryQuerier_Aggregate_Call struct {
	*mock.Call
}

// Aggregate is a helper method to define mock.On call
//   - ctx context.Context
//   - aggregateType AggregateType
//   - serviceID properties.UUID
//   - typeID properties.UUID
//   - start time.Time
//   - end time.Time
func (_e *MockMetricEntryQuerier_Expecter) Aggregate(ctx interface{}, aggregateType interface{}, serviceID interface{}, typeID interface{}, start interface{}, end interface{}) *MockMetricEntryQuerier_Aggregate_Call {
	return &MockMetricEntryQuerier_Aggregate_Call{Call: _e.mock.On("Aggregate", ctx, aggregateType, serviceID, typeID, start, end)}
}

func (_c *MockMetricEntryQuerier_Aggregate_Call) Run(run func(ctx context.Context, aggregateType AggregateType, serviceID properties.UUID, typeID properties.UUID, start time.Time, end time.Time)) *MockMetricEntryQuerier_Aggregate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 AggregateType
		if args[1] != nil {
			arg1 = args[1].(AggregateType)
		}
		var arg2 properties.UUID
		if args[2] != nil {
			arg2 = args[2].(properties.UUID)
		}
		var arg3 properties.UUID
		if args[3] != nil {
			arg3 = args[3].(properties.UUID)
		}
		var arg4 time.Time
		if args[4] != nil {
			arg4 = args[4].(time.Time)
		}
		var arg5 time.Time
		if args[5] != nil {
			arg5 = args[5].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockMetricEntryQuerier_Aggregate_Call) Return(f float64, err error) *MockMetricEntryQuerier_Aggregate_Call {
	_c.Call.Return(f, err)
	return _c
}

func (_c *MockMetricEntryQuerier_Aggregate_Call) RunAndReturn(run func(ctx context.Context, aggregateType AggregateType, serviceID properties.UUID, typeID properties.UUID, start time.Time, end time.Time) (float64, error)) *MockMetricEntryQuerier_Aggregate_Call {
	_c.Call.Return(run)
	return _c
}

// AuthScope provides a mock function for the type MockMetricEntryQuerier
func (_mock *MockMetricEntryQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockMetricEntryQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricEntryQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockMetricEntryQuerier_AuthScope_Call {
	return &MockMetricEntryQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockMetricEntryQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricEntryQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockMetricEntryQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockMetricEntryQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockMetricEntryQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockMetricEntryQuerier
func (_mock *MockMetricEntryQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockMetricEntryQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMetricEntryQuerier_Expecter) Count(ctx interface{}) *MockMetricEntryQuerier_Count_Call {
	return &MockMetricEntryQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockMetricEntryQuerier_Count_Call) Run(run func(ctx context.Context)) *MockMetricEntryQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMetricEntryQuerier_Count_Call) Return(n int64, err error) *MockMetricEntryQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMetricEntryQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockMetricEntryQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CountByMetricType provides a mock function for the type MockMetricEntryQuerier
func (_mock *MockMetricEntryQuerier) CountByMetricType(ctx context.Context, typeID properties.UUID) (int64, error) {
	ret := _mock.Called(ctx, typeID)

	if len(ret) == 0 {
		panic("no return value specified for CountByMetricType")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (int64, error)); ok {
		return returnFunc(ctx, typeID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) int64); ok {
		r0 = returnFunc(ctx, typeID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, typeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryQuerier_CountByMetricType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByMetricType'
type MockMetricEntryQuerier_CountByMetricType_Call struct {
	*mock.Call
}

// CountByMetricType is a helper method to define mock.On call
//   - ctx context.Context
//   - typeID properties.UUID
func (_e *MockMetricEntryQuerier_Expecter) CountByMetricType(ctx interface{}, typeID interface{}) *MockMetricEntryQuerier_CountByMetricType_Call {
	return &MockMetricEntryQuerier_CountByMetricType_Call{Call: _e.mock.On("CountByMetricType", ctx, typeID)}
}

func (_c *MockMetricEntryQuerier_CountByMetricType_Call) Run(run func(ctx context.Context, typeID properties.UUID)) *MockMetricEntryQuerier_CountByMetricType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryQuerier_CountByMetricType_Call) Return(n int64, err error) *MockMetricEntryQuerier_CountByMetricType_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMetricEntryQuerier_CountByMetricType_Call) RunAndReturn(run func(ctx context.Context, typeID properties.UUID) (int64, error)) *MockMetricEntryQuerier_CountByMetricType_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockMetricEntryQuerier
func (_mock *MockMetricEntryQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockMetricEntryQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricEntryQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockMetricEntryQuerier_Exists_Call {
	return &MockMetricEntryQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockMetricEntryQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricEntryQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryQuerier_Exists_Call) Return(b bool, err error) *MockMetricEntryQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockMetricEntryQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockMetricEntryQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockMetricEntryQuerier
func (_mock *MockMetricEntryQuerier) Get(ctx context.Context, id properties.UUID) (*MetricEntry, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *MetricEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*MetricEntry, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *MetricEntry); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockMetricEntryQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricEntryQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockMetricEntryQuerier_Get_Call {
	return &MockMetricEntryQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockMetricEntryQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricEntryQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricEntryQuerier_Get_Call) Return(metricEntry *MetricEntry, err error) *MockMetricEntryQuerier_Get_Call {
	_c.Call.Return(metricEntry, err)
	return _c
}

func (_c *MockMetricEntryQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*MetricEntry, error)) *MockMetricEntryQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockMetricEntryQuerier
func (_mock *MockMetricEntryQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[MetricEntry], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[MetricEntry]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[MetricEntry], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[MetricEntry]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[MetricEntry])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricEntryQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockMetricEntryQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockMetricEntryQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockMetricEntryQuerier_List_Call {
	return &MockMetricEntryQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockMetricEntryQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockMetricEntryQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMetricEntryQuerier_List_Call) Return(pageRes *PageRes[MetricEntry], err error) *MockMetricEntryQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockMetricEntryQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[MetricEntry], error)) *MockMetricEntryQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetricTypeCommander creates a new instance of MockMetricTypeCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetricTypeCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetricTypeCommander {
	mock := &MockMetricTypeCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetricTypeCommander is an autogenerated mock type for the MetricTypeCommander type
type MockMetricTypeCommander struct {
	mock.Mock
}

type MockMetricTypeCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetricTypeCommander) EXPECT() *MockMetricTypeCommander_Expecter {
	return &MockMetricTypeCommander_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockMetricTypeCommander
func (_mock *MockMetricTypeCommander) Create(ctx context.Context, name string, kind MetricEntityType) (*MetricType, error) {
	ret := _mock.Called(ctx, name, kind)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *MetricType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, MetricEntityType) (*MetricType, error)); ok {
		return returnFunc(ctx, name, kind)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, MetricEntityType) *MetricType); ok {
		r0 = returnFunc(ctx, name, kind)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, MetricEntityType) error); ok {
		r1 = returnFunc(ctx, name, kind)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeCommander_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockMetricTypeCommander_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - kind MetricEntityType
func (_e *MockMetricTypeCommander_Expecter) Create(ctx interface{}, name interface{}, kind interface{}) *MockMetricTypeCommander_Create_Call {
	return &MockMetricTypeCommander_Create_Call{Call: _e.mock.On("Create", ctx, name, kind)}
}

func (_c *MockMetricTypeCommander_Create_Call) Run(run func(ctx context.Context, name string, kind MetricEntityType)) *MockMetricTypeCommander_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 MetricEntityType
		if args[2] != nil {
			arg2 = args[2].(MetricEntityType)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMetricTypeCommander_Create_Call) Return(metricType *MetricType, err error) *MockMetricTypeCommander_Create_Call {
	_c.Call.Return(metricType, err)
	return _c
}

func (_c *MockMetricTypeCommander_Create_Call) RunAndReturn(run func(ctx context.Context, name string, kind MetricEntityType) (*MetricType, error)) *MockMetricTypeCommander_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockMetricTypeCommander
func (_mock *MockMetricTypeCommander) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMetricTypeCommander_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockMetricTypeCommander_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricTypeCommander_Expecter) Delete(ctx interface{}, id interface{}) *MockMetricTypeCommander_Delete_Call {
	return &MockMetricTypeCommander_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockMetricTypeCommander_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricTypeCommander_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeCommander_Delete_Call) Return(err error) *MockMetricTypeCommander_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMetricTypeCommander_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockMetricTypeCommander_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockMetricTypeCommander
func (_mock *MockMetricTypeCommander) Update(ctx context.Context, id properties.UUID, name *string) (*MetricType, error) {
	ret := _mock.Called(ctx, id, name)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *MetricType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string) (*MetricType, error)); ok {
		return returnFunc(ctx, id, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string) *MetricType); ok {
		r0 = returnFunc(ctx, id, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, *string) error); ok {
		r1 = returnFunc(ctx, id, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeCommander_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockMetricTypeCommander_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
//   - name *string
func (_e *MockMetricTypeCommander_Expecter) Update(ctx interface{}, id interface{}, name interface{}) *MockMetricTypeCommander_Update_Call {
	return &MockMetricTypeCommander_Update_Call{Call: _e.mock.On("Update", ctx, id, name)}
}

func (_c *MockMetricTypeCommander_Update_Call) Run(run func(ctx context.Context, id properties.UUID, name *string)) *MockMetricTypeCommander_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMetricTypeCommander_Update_Call) Return(metricType *MetricType, err error) *MockMetricTypeCommander_Update_Call {
	_c.Call.Return(metricType, err)
	return _c
}

func (_c *MockMetricTypeCommander_Update_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID, name *string) (*MetricType, error)) *MockMetricTypeCommander_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetricTypeRepository creates a new instance of MockMetricTypeRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetricTypeRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetricTypeRepository {
	mock := &MockMetricTypeRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetricTypeRepository is an autogenerated mock type for the MetricTypeRepository type
type MockMetricTypeRepository struct {
	mock.Mock
}

type MockMetricTypeRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetricTypeRepository) EXPECT() *MockMetricTypeRepository_Expecter {
	return &MockMetricTypeRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockMetricTypeRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricTypeRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockMetricTypeRepository_AuthScope_Call {
	return &MockMetricTypeRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockMetricTypeRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricTypeRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockMetricTypeRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockMetricTypeRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockMetricTypeRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockMetricTypeRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMetricTypeRepository_Expecter) Count(ctx interface{}) *MockMetricTypeRepository_Count_Call {
	return &MockMetricTypeRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockMetricTypeRepository_Count_Call) Run(run func(ctx context.Context)) *MockMetricTypeRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_Count_Call) Return(n int64, err error) *MockMetricTypeRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMetricTypeRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockMetricTypeRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) Create(ctx context.Context, entity *MetricType) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *MetricType) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMetricTypeRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockMetricTypeRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *MetricType
func (_e *MockMetricTypeRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockMetricTypeRepository_Create_Call {
	return &MockMetricTypeRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockMetricTypeRepository_Create_Call) Run(run func(ctx context.Context, entity *MetricType)) *MockMetricTypeRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *MetricType
		if args[1] != nil {
			arg1 = args[1].(*MetricType)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_Create_Call) Return(err error) *MockMetricTypeRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMetricTypeRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *MetricType) error) *MockMetricTypeRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMetricTypeRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockMetricTypeRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricTypeRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockMetricTypeRepository_Delete_Call {
	return &MockMetricTypeRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockMetricTypeRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricTypeRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_Delete_Call) Return(err error) *MockMetricTypeRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMetricTypeRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockMetricTypeRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockMetricTypeRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricTypeRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockMetricTypeRepository_Exists_Call {
	return &MockMetricTypeRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockMetricTypeRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricTypeRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_Exists_Call) Return(b bool, err error) *MockMetricTypeRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockMetricTypeRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockMetricTypeRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FindByName provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) FindByName(ctx context.Context, name string) (*MetricType, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for FindByName")
	}

	var r0 *MetricType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*MetricType, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *MetricType); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeRepository_FindByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByName'
type MockMetricTypeRepository_FindByName_Call struct {
	*mock.Call
}

// FindByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockMetricTypeRepository_Expecter) FindByName(ctx interface{}, name interface{}) *MockMetricTypeRepository_FindByName_Call {
	return &MockMetricTypeRepository_FindByName_Call{Call: _e.mock.On("FindByName", ctx, name)}
}

func (_c *MockMetricTypeRepository_FindByName_Call) Run(run func(ctx context.Context, name string)) *MockMetricTypeRepository_FindByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_FindByName_Call) Return(metricType *MetricType, err error) *MockMetricTypeRepository_FindByName_Call {
	_c.Call.Return(metricType, err)
	return _c
}

func (_c *MockMetricTypeRepository_FindByName_Call) RunAndReturn(run func(ctx context.Context, name string) (*MetricType, error)) *MockMetricTypeRepository_FindByName_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) Get(ctx context.Context, id properties.UUID) (*MetricType, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *MetricType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*MetricType, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *MetricType); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockMetricTypeRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricTypeRepository_Expecter) Get(ctx interface{}, id interface{}) *MockMetricTypeRepository_Get_Call {
	return &MockMetricTypeRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockMetricTypeRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricTypeRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_Get_Call) Return(metricType *MetricType, err error) *MockMetricTypeRepository_Get_Call {
	_c.Call.Return(metricType, err)
	return _c
}

func (_c *MockMetricTypeRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*MetricType, error)) *MockMetricTypeRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[MetricType], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[MetricType]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[MetricType], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[MetricType]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[MetricType])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockMetricTypeRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockMetricTypeRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockMetricTypeRepository_List_Call {
	return &MockMetricTypeRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockMetricTypeRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockMetricTypeRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_List_Call) Return(pageRes *PageRes[MetricType], err error) *MockMetricTypeRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockMetricTypeRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[MetricType], error)) *MockMetricTypeRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockMetricTypeRepository
func (_mock *MockMetricTypeRepository) Save(ctx context.Context, entity *MetricType) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *MetricType) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMetricTypeRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockMetricTypeRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *MetricType
func (_e *MockMetricTypeRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockMetricTypeRepository_Save_Call {
	return &MockMetricTypeRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockMetricTypeRepository_Save_Call) Run(run func(ctx context.Context, entity *MetricType)) *MockMetricTypeRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *MetricType
		if args[1] != nil {
			arg1 = args[1].(*MetricType)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeRepository_Save_Call) Return(err error) *MockMetricTypeRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMetricTypeRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *MetricType) error) *MockMetricTypeRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetricTypeQuerier creates a new instance of MockMetricTypeQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetricTypeQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetricTypeQuerier {
	mock := &MockMetricTypeQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetricTypeQuerier is an autogenerated mock type for the MetricTypeQuerier type
type MockMetricTypeQuerier struct {
	mock.Mock
}

type MockMetricTypeQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetricTypeQuerier) EXPECT() *MockMetricTypeQuerier_Expecter {
	return &MockMetricTypeQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockMetricTypeQuerier
func (_mock *MockMetricTypeQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockMetricTypeQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricTypeQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockMetricTypeQuerier_AuthScope_Call {
	return &MockMetricTypeQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockMetricTypeQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricTypeQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockMetricTypeQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockMetricTypeQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockMetricTypeQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockMetricTypeQuerier
func (_mock *MockMetricTypeQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockMetricTypeQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMetricTypeQuerier_Expecter) Count(ctx interface{}) *MockMetricTypeQuerier_Count_Call {
	return &MockMetricTypeQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockMetricTypeQuerier_Count_Call) Run(run func(ctx context.Context)) *MockMetricTypeQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMetricTypeQuerier_Count_Call) Return(n int64, err error) *MockMetricTypeQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMetricTypeQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockMetricTypeQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockMetricTypeQuerier
func (_mock *MockMetricTypeQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockMetricTypeQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricTypeQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockMetricTypeQuerier_Exists_Call {
	return &MockMetricTypeQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockMetricTypeQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricTypeQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeQuerier_Exists_Call) Return(b bool, err error) *MockMetricTypeQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockMetricTypeQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockMetricTypeQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FindByName provides a mock function for the type MockMetricTypeQuerier
func (_mock *MockMetricTypeQuerier) FindByName(ctx context.Context, name string) (*MetricType, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for FindByName")
	}

	var r0 *MetricType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*MetricType, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *MetricType); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeQuerier_FindByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByName'
type MockMetricTypeQuerier_FindByName_Call struct {
	*mock.Call
}

// FindByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockMetricTypeQuerier_Expecter) FindByName(ctx interface{}, name interface{}) *MockMetricTypeQuerier_FindByName_Call {
	return &MockMetricTypeQuerier_FindByName_Call{Call: _e.mock.On("FindByName", ctx, name)}
}

func (_c *MockMetricTypeQuerier_FindByName_Call) Run(run func(ctx context.Context, name string)) *MockMetricTypeQuerier_FindByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeQuerier_FindByName_Call) Return(metricType *MetricType, err error) *MockMetricTypeQuerier_FindByName_Call {
	_c.Call.Return(metricType, err)
	return _c
}

func (_c *MockMetricTypeQuerier_FindByName_Call) RunAndReturn(run func(ctx context.Context, name string) (*MetricType, error)) *MockMetricTypeQuerier_FindByName_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockMetricTypeQuerier
func (_mock *MockMetricTypeQuerier) Get(ctx context.Context, id properties.UUID) (*MetricType, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *MetricType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*MetricType, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *MetricType); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MetricType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockMetricTypeQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockMetricTypeQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockMetricTypeQuerier_Get_Call {
	return &MockMetricTypeQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockMetricTypeQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockMetricTypeQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetricTypeQuerier_Get_Call) Return(metricType *MetricType, err error) *MockMetricTypeQuerier_Get_Call {
	_c.Call.Return(metricType, err)
	return _c
}

func (_c *MockMetricTypeQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*MetricType, error)) *MockMetricTypeQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockMetricTypeQuerier
func (_mock *MockMetricTypeQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[MetricType], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[MetricType]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[MetricType], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[MetricType]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[MetricType])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricTypeQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockMetricTypeQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockMetricTypeQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockMetricTypeQuerier_List_Call {
	return &MockMetricTypeQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockMetricTypeQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockMetricTypeQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMetricTypeQuerier_List_Call) Return(pageRes *PageRes[MetricType], err error) *MockMetricTypeQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockMetricTypeQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[MetricType], error)) *MockMetricTypeQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockParticipantCommander creates a new instance of MockParticipantCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockParticipantCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockParticipantCommander {
	mock := &MockParticipantCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockParticipantCommander is an autogenerated mock type for the ParticipantCommander type
type MockParticipantCommander struct {
	mock.Mock
}

type MockParticipantCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockParticipantCommander) EXPECT() *MockParticipantCommander_Expecter {
	return &MockParticipantCommander_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockParticipantCommander
func (_mock *MockParticipantCommander) Create(ctx context.Context, name string, status ParticipantStatus) (*Participant, error) {
	ret := _mock.Called(ctx, name, status)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ParticipantStatus) (*Participant, error)); ok {
		return returnFunc(ctx, name, status)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ParticipantStatus) *Participant); ok {
		r0 = returnFunc(ctx, name, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Participant)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ParticipantStatus) error); ok {
		r1 = returnFunc(ctx, name, status)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantCommander_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockParticipantCommander_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - status ParticipantStatus
func (_e *MockParticipantCommander_Expecter) Create(ctx interface{}, name interface{}, status interface{}) *MockParticipantCommander_Create_Call {
	return &MockParticipantCommander_Create_Call{Call: _e.mock.On("Create", ctx, name, status)}
}

func (_c *MockParticipantCommander_Create_Call) Run(run func(ctx context.Context, name string, status ParticipantStatus)) *MockParticipantCommander_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 ParticipantStatus
		if args[2] != nil {
			arg2 = args[2].(ParticipantStatus)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockParticipantCommander_Create_Call) Return(participant *Participant, err error) *MockParticipantCommander_Create_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *MockParticipantCommander_Create_Call) RunAndReturn(run func(ctx context.Context, name string, status ParticipantStatus) (*Participant, error)) *MockParticipantCommander_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockParticipantCommander
func (_mock *MockParticipantCommander) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockParticipantCommander_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockParticipantCommander_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockParticipantCommander_Expecter) Delete(ctx interface{}, id interface{}) *MockParticipantCommander_Delete_Call {
	return &MockParticipantCommander_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockParticipantCommander_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockParticipantCommander_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantCommander_Delete_Call) Return(err error) *MockParticipantCommander_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockParticipantCommander_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockParticipantCommander_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockParticipantCommander
func (_mock *MockParticipantCommander) Update(ctx context.Context, id properties.UUID, name *string, status *ParticipantStatus) (*Participant, error) {
	ret := _mock.Called(ctx, id, name, status)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string, *ParticipantStatus) (*Participant, error)); ok {
		return returnFunc(ctx, id, name, status)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string, *ParticipantStatus) *Participant); ok {
		r0 = returnFunc(ctx, id, name, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Participant)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, *string, *ParticipantStatus) error); ok {
		r1 = returnFunc(ctx, id, name, status)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantCommander_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockParticipantCommander_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
//   - name *string
//   - status *ParticipantStatus
func (_e *MockParticipantCommander_Expecter) Update(ctx interface{}, id interface{}, name interface{}, status interface{}) *MockParticipantCommander_Update_Call {
	return &MockParticipantCommander_Update_Call{Call: _e.mock.On("Update", ctx, id, name, status)}
}

func (_c *MockParticipantCommander_Update_Call) Run(run func(ctx context.Context, id properties.UUID, name *string, status *ParticipantStatus)) *MockParticipantCommander_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		var arg3 *ParticipantStatus
		if args[3] != nil {
			arg3 = args[3].(*ParticipantStatus)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockParticipantCommander_Update_Call) Return(participant *Participant, err error) *MockParticipantCommander_Update_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *MockParticipantCommander_Update_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID, name *string, status *ParticipantStatus) (*Participant, error)) *MockParticipantCommander_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockParticipantRepository creates a new instance of MockParticipantRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockParticipantRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockParticipantRepository {
	mock := &MockParticipantRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockParticipantRepository is an autogenerated mock type for the ParticipantRepository type
type MockParticipantRepository struct {
	mock.Mock
}

type MockParticipantRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockParticipantRepository) EXPECT() *MockParticipantRepository_Expecter {
	return &MockParticipantRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockParticipantRepository
func (_mock *MockParticipantRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockParticipantRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockParticipantRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockParticipantRepository_AuthScope_Call {
	return &MockParticipantRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockParticipantRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockParticipantRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockParticipantRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockParticipantRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockParticipantRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockParticipantRepository
func (_mock *MockParticipantRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockParticipantRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockParticipantRepository_Expecter) Count(ctx interface{}) *MockParticipantRepository_Count_Call {
	return &MockParticipantRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockParticipantRepository_Count_Call) Run(run func(ctx context.Context)) *MockParticipantRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockParticipantRepository_Count_Call) Return(n int64, err error) *MockParticipantRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockParticipantRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockParticipantRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockParticipantRepository
func (_mock *MockParticipantRepository) Create(ctx context.Context, entity *Participant) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Participant) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockParticipantRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockParticipantRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Participant
func (_e *MockParticipantRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockParticipantRepository_Create_Call {
	return &MockParticipantRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockParticipantRepository_Create_Call) Run(run func(ctx context.Context, entity *Participant)) *MockParticipantRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Participant
		if args[1] != nil {
			arg1 = args[1].(*Participant)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantRepository_Create_Call) Return(err error) *MockParticipantRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockParticipantRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *Participant) error) *MockParticipantRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockParticipantRepository
func (_mock *MockParticipantRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockParticipantRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockParticipantRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockParticipantRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockParticipantRepository_Delete_Call {
	return &MockParticipantRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockParticipantRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockParticipantRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantRepository_Delete_Call) Return(err error) *MockParticipantRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockParticipantRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockParticipantRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockParticipantRepository
func (_mock *MockParticipantRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockParticipantRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockParticipantRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockParticipantRepository_Exists_Call {
	return &MockParticipantRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockParticipantRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockParticipantRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantRepository_Exists_Call) Return(b bool, err error) *MockParticipantRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockParticipantRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockParticipantRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockParticipantRepository
func (_mock *MockParticipantRepository) Get(ctx context.Context, id properties.UUID) (*Participant, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Participant, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Participant); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Participant)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockParticipantRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockParticipantRepository_Expecter) Get(ctx interface{}, id interface{}) *MockParticipantRepository_Get_Call {
	return &MockParticipantRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockParticipantRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockParticipantRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantRepository_Get_Call) Return(participant *Participant, err error) *MockParticipantRepository_Get_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *MockParticipantRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Participant, error)) *MockParticipantRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockParticipantRepository
func (_mock *MockParticipantRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Participant], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Participant]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Participant], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Participant]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Participant])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockParticipantRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockParticipantRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockParticipantRepository_List_Call {
	return &MockParticipantRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockParticipantRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockParticipantRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockParticipantRepository_List_Call) Return(pageRes *PageRes[Participant], err error) *MockParticipantRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockParticipantRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Participant], error)) *MockParticipantRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockParticipantRepository
func (_mock *MockParticipantRepository) Save(ctx context.Context, entity *Participant) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Participant) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockParticipantRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockParticipantRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Participant
func (_e *MockParticipantRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockParticipantRepository_Save_Call {
	return &MockParticipantRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockParticipantRepository_Save_Call) Run(run func(ctx context.Context, entity *Participant)) *MockParticipantRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Participant
		if args[1] != nil {
			arg1 = args[1].(*Participant)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantRepository_Save_Call) Return(err error) *MockParticipantRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockParticipantRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *Participant) error) *MockParticipantRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockParticipantQuerier creates a new instance of MockParticipantQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockParticipantQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockParticipantQuerier {
	mock := &MockParticipantQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockParticipantQuerier is an autogenerated mock type for the ParticipantQuerier type
type MockParticipantQuerier struct {
	mock.Mock
}

type MockParticipantQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockParticipantQuerier) EXPECT() *MockParticipantQuerier_Expecter {
	return &MockParticipantQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockParticipantQuerier
func (_mock *MockParticipantQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockParticipantQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockParticipantQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockParticipantQuerier_AuthScope_Call {
	return &MockParticipantQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockParticipantQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockParticipantQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockParticipantQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockParticipantQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockParticipantQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockParticipantQuerier
func (_mock *MockParticipantQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockParticipantQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockParticipantQuerier_Expecter) Count(ctx interface{}) *MockParticipantQuerier_Count_Call {
	return &MockParticipantQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockParticipantQuerier_Count_Call) Run(run func(ctx context.Context)) *MockParticipantQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockParticipantQuerier_Count_Call) Return(n int64, err error) *MockParticipantQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockParticipantQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockParticipantQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockParticipantQuerier
func (_mock *MockParticipantQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockParticipantQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockParticipantQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockParticipantQuerier_Exists_Call {
	return &MockParticipantQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockParticipantQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockParticipantQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantQuerier_Exists_Call) Return(b bool, err error) *MockParticipantQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockParticipantQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockParticipantQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockParticipantQuerier
func (_mock *MockParticipantQuerier) Get(ctx context.Context, id properties.UUID) (*Participant, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Participant, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Participant); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Participant)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockParticipantQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockParticipantQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockParticipantQuerier_Get_Call {
	return &MockParticipantQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockParticipantQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockParticipantQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockParticipantQuerier_Get_Call) Return(participant *Participant, err error) *MockParticipantQuerier_Get_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *MockParticipantQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Participant, error)) *MockParticipantQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockParticipantQuerier
func (_mock *MockParticipantQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Participant], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Participant]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Participant], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Participant]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Participant])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockParticipantQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockParticipantQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockParticipantQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockParticipantQuerier_List_Call {
	return &MockParticipantQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockParticipantQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockParticipantQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockParticipantQuerier_List_Call) Return(pageRes *PageRes[Participant], err error) *MockParticipantQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockParticipantQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Participant], error)) *MockParticipantQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServiceCommander creates a new instance of MockServiceCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServiceCommander {
	mock := &MockServiceCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockServiceCommander is an autogenerated mock type for the ServiceCommander type
type MockServiceCommander struct {
	mock.Mock
}

type MockServiceCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServiceCommander) EXPECT() *MockServiceCommander_Expecter {
	return &MockServiceCommander_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockServiceCommander
func (_mock *MockServiceCommander) Create(ctx context.Context, agentID properties.UUID, serviceTypeID properties.UUID, groupID properties.UUID, name string, properties1 properties.JSON) (*Service, error) {
	ret := _mock.Called(ctx, agentID, serviceTypeID, groupID, name, properties1)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, properties.UUID, properties.UUID, string, properties.JSON) (*Service, error)); ok {
		return returnFunc(ctx, agentID, serviceTypeID, groupID, name, properties1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, properties.UUID, properties.UUID, string, properties.JSON) *Service); ok {
		r0 = returnFunc(ctx, agentID, serviceTypeID, groupID, name, properties1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, properties.UUID, properties.UUID, string, properties.JSON) error); ok {
		r1 = returnFunc(ctx, agentID, serviceTypeID, groupID, name, properties1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceCommander_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockServiceCommander_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID properties.UUID
//   - serviceTypeID properties.UUID
//   - groupID properties.UUID
//   - name string
//   - properties1 properties.JSON
func (_e *MockServiceCommander_Expecter) Create(ctx interface{}, agentID interface{}, serviceTypeID interface{}, groupID interface{}, name interface{}, properties1 interface{}) *MockServiceCommander_Create_Call {
	return &MockServiceCommander_Create_Call{Call: _e.mock.On("Create", ctx, agentID, serviceTypeID, groupID, name, properties1)}
}

func (_c *MockServiceCommander_Create_Call) Run(run func(ctx context.Context, agentID properties.UUID, serviceTypeID properties.UUID, groupID properties.UUID, name string, properties1 properties.JSON)) *MockServiceCommander_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 properties.UUID
		if args[2] != nil {
			arg2 = args[2].(properties.UUID)
		}
		var arg3 properties.UUID
		if args[3] != nil {
			arg3 = args[3].(properties.UUID)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 properties.JSON
		if args[5] != nil {
			arg5 = args[5].(properties.JSON)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockServiceCommander_Create_Call) Return(service *Service, err error) *MockServiceCommander_Create_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceCommander_Create_Call) RunAndReturn(run func(ctx context.Context, agentID properties.UUID, serviceTypeID properties.UUID, groupID properties.UUID, name string, properties1 properties.JSON) (*Service, error)) *MockServiceCommander_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWithTags provides a mock function for the type MockServiceCommander
func (_mock *MockServiceCommander) CreateWithTags(ctx context.Context, serviceTypeID properties.UUID, groupID properties.UUID, name string, properties1 properties.JSON, serviceTags []string) (*Service, error) {
	ret := _mock.Called(ctx, serviceTypeID, groupID, name, properties1, serviceTags)

	if len(ret) == 0 {
		panic("no return value specified for CreateWithTags")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, properties.UUID, string, properties.JSON, []string) (*Service, error)); ok {
		return returnFunc(ctx, serviceTypeID, groupID, name, properties1, serviceTags)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, properties.UUID, string, properties.JSON, []string) *Service); ok {
		r0 = returnFunc(ctx, serviceTypeID, groupID, name, properties1, serviceTags)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, properties.UUID, string, properties.JSON, []string) error); ok {
		r1 = returnFunc(ctx, serviceTypeID, groupID, name, properties1, serviceTags)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceCommander_CreateWithTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWithTags'
type MockServiceCommander_CreateWithTags_Call struct {
	*mock.Call
}

// CreateWithTags is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceTypeID properties.UUID
//   - groupID properties.UUID
//   - name string
//   - properties1 properties.JSON
//   - serviceTags []string
func (_e *MockServiceCommander_Expecter) CreateWithTags(ctx interface{}, serviceTypeID interface{}, groupID interface{}, name interface{}, properties1 interface{}, serviceTags interface{}) *MockServiceCommander_CreateWithTags_Call {
	return &MockServiceCommander_CreateWithTags_Call{Call: _e.mock.On("CreateWithTags", ctx, serviceTypeID, groupID, name, properties1, serviceTags)}
}

func (_c *MockServiceCommander_CreateWithTags_Call) Run(run func(ctx context.Context, serviceTypeID properties.UUID, groupID properties.UUID, name string, properties1 properties.JSON, serviceTags []string)) *MockServiceCommander_CreateWithTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 properties.UUID
		if args[2] != nil {
			arg2 = args[2].(properties.UUID)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 properties.JSON
		if args[4] != nil {
			arg4 = args[4].(properties.JSON)
		}
		var arg5 []string
		if args[5] != nil {
			arg5 = args[5].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockServiceCommander_CreateWithTags_Call) Return(service *Service, err error) *MockServiceCommander_CreateWithTags_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceCommander_CreateWithTags_Call) RunAndReturn(run func(ctx context.Context, serviceTypeID properties.UUID, groupID properties.UUID, name string, properties1 properties.JSON, serviceTags []string) (*Service, error)) *MockServiceCommander_CreateWithTags_Call {
	_c.Call.Return(run)
	return _c
}

// FailTimeoutServicesAndJobs provides a mock function for the type MockServiceCommander
func (_mock *MockServiceCommander) FailTimeoutServicesAndJobs(ctx context.Context, timeout time.Duration) (int, error) {
	ret := _mock.Called(ctx, timeout)

	if len(ret) == 0 {
		panic("no return value specified for FailTimeoutServicesAndJobs")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) (int, error)); ok {
		return returnFunc(ctx, timeout)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) int); ok {
		r0 = returnFunc(ctx, timeout)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = returnFunc(ctx, timeout)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceCommander_FailTimeoutServicesAndJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FailTimeoutServicesAndJobs'
type MockServiceCommander_FailTimeoutServicesAndJobs_Call struct {
	*mock.Call
}

// FailTimeoutServicesAndJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
func (_e *MockServiceCommander_Expecter) FailTimeoutServicesAndJobs(ctx interface{}, timeout interface{}) *MockServiceCommander_FailTimeoutServicesAndJobs_Call {
	return &MockServiceCommander_FailTimeoutServicesAndJobs_Call{Call: _e.mock.On("FailTimeoutServicesAndJobs", ctx, timeout)}
}

func (_c *MockServiceCommander_FailTimeoutServicesAndJobs_Call) Run(run func(ctx context.Context, timeout time.Duration)) *MockServiceCommander_FailTimeoutServicesAndJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceCommander_FailTimeoutServicesAndJobs_Call) Return(n int, err error) *MockServiceCommander_FailTimeoutServicesAndJobs_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceCommander_FailTimeoutServicesAndJobs_Call) RunAndReturn(run func(ctx context.Context, timeout time.Duration) (int, error)) *MockServiceCommander_FailTimeoutServicesAndJobs_Call {
	_c.Call.Return(run)
	return _c
}

// Retry provides a mock function for the type MockServiceCommander
func (_mock *MockServiceCommander) Retry(ctx context.Context, id properties.UUID) (*Service, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Retry")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Service, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Service); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceCommander_Retry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Retry'
type MockServiceCommander_Retry_Call struct {
	*mock.Call
}

// Retry is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceCommander_Expecter) Retry(ctx interface{}, id interface{}) *MockServiceCommander_Retry_Call {
	return &MockServiceCommander_Retry_Call{Call: _e.mock.On("Retry", ctx, id)}
}

func (_c *MockServiceCommander_Retry_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceCommander_Retry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceCommander_Retry_Call) Return(service *Service, err error) *MockServiceCommander_Retry_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceCommander_Retry_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Service, error)) *MockServiceCommander_Retry_Call {
	_c.Call.Return(run)
	return _c
}

// Transition provides a mock function for the type MockServiceCommander
func (_mock *MockServiceCommander) Transition(ctx context.Context, id properties.UUID, target ServiceStatus) (*Service, error) {
	ret := _mock.Called(ctx, id, target)

	if len(ret) == 0 {
		panic("no return value specified for Transition")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, ServiceStatus) (*Service, error)); ok {
		return returnFunc(ctx, id, target)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, ServiceStatus) *Service); ok {
		r0 = returnFunc(ctx, id, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, ServiceStatus) error); ok {
		r1 = returnFunc(ctx, id, target)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceCommander_Transition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transition'
type MockServiceCommander_Transition_Call struct {
	*mock.Call
}

// Transition is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
//   - target ServiceStatus
func (_e *MockServiceCommander_Expecter) Transition(ctx interface{}, id interface{}, target interface{}) *MockServiceCommander_Transition_Call {
	return &MockServiceCommander_Transition_Call{Call: _e.mock.On("Transition", ctx, id, target)}
}

func (_c *MockServiceCommander_Transition_Call) Run(run func(ctx context.Context, id properties.UUID, target ServiceStatus)) *MockServiceCommander_Transition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 ServiceStatus
		if args[2] != nil {
			arg2 = args[2].(ServiceStatus)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceCommander_Transition_Call) Return(service *Service, err error) *MockServiceCommander_Transition_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceCommander_Transition_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID, target ServiceStatus) (*Service, error)) *MockServiceCommander_Transition_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockServiceCommander
func (_mock *MockServiceCommander) Update(ctx context.Context, id properties.UUID, name *string, props *properties.JSON) (*Service, error) {
	ret := _mock.Called(ctx, id, name, props)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string, *properties.JSON) (*Service, error)); ok {
		return returnFunc(ctx, id, name, props)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string, *properties.JSON) *Service); ok {
		r0 = returnFunc(ctx, id, name, props)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, *string, *properties.JSON) error); ok {
		r1 = returnFunc(ctx, id, name, props)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceCommander_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockServiceCommander_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
//   - name *string
//   - props *properties.JSON
func (_e *MockServiceCommander_Expecter) Update(ctx interface{}, id interface{}, name interface{}, props interface{}) *MockServiceCommander_Update_Call {
	return &MockServiceCommander_Update_Call{Call: _e.mock.On("Update", ctx, id, name, props)}
}

func (_c *MockServiceCommander_Update_Call) Run(run func(ctx context.Context, id properties.UUID, name *string, props *properties.JSON)) *MockServiceCommander_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		var arg3 *properties.JSON
		if args[3] != nil {
			arg3 = args[3].(*properties.JSON)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockServiceCommander_Update_Call) Return(service *Service, err error) *MockServiceCommander_Update_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceCommander_Update_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID, name *string, props *properties.JSON) (*Service, error)) *MockServiceCommander_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServiceRepository creates a new instance of MockServiceRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServiceRepository {
	mock := &MockServiceRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockServiceRepository is an autogenerated mock type for the ServiceRepository type
type MockServiceRepository struct {
	mock.Mock
}

type MockServiceRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServiceRepository) EXPECT() *MockServiceRepository_Expecter {
	return &MockServiceRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockServiceRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockServiceRepository_AuthScope_Call {
	return &MockServiceRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockServiceRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockServiceRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockServiceRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockServiceRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockServiceRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockServiceRepository_Expecter) Count(ctx interface{}) *MockServiceRepository_Count_Call {
	return &MockServiceRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockServiceRepository_Count_Call) Run(run func(ctx context.Context)) *MockServiceRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockServiceRepository_Count_Call) Return(n int64, err error) *MockServiceRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockServiceRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CountByAgent provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) CountByAgent(ctx context.Context, agentID properties.UUID) (int64, error) {
	ret := _mock.Called(ctx, agentID)

	if len(ret) == 0 {
		panic("no return value specified for CountByAgent")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (int64, error)); ok {
		return returnFunc(ctx, agentID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) int64); ok {
		r0 = returnFunc(ctx, agentID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, agentID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceRepository_CountByAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByAgent'
type MockServiceRepository_CountByAgent_Call struct {
	*mock.Call
}

// CountByAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID properties.UUID
func (_e *MockServiceRepository_Expecter) CountByAgent(ctx interface{}, agentID interface{}) *MockServiceRepository_CountByAgent_Call {
	return &MockServiceRepository_CountByAgent_Call{Call: _e.mock.On("CountByAgent", ctx, agentID)}
}

func (_c *MockServiceRepository_CountByAgent_Call) Run(run func(ctx context.Context, agentID properties.UUID)) *MockServiceRepository_CountByAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceRepository_CountByAgent_Call) Return(n int64, err error) *MockServiceRepository_CountByAgent_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceRepository_CountByAgent_Call) RunAndReturn(run func(ctx context.Context, agentID properties.UUID) (int64, error)) *MockServiceRepository_CountByAgent_Call {
	_c.Call.Return(run)
	return _c
}

// CountByGroup provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) CountByGroup(ctx context.Context, groupID properties.UUID) (int64, error) {
	ret := _mock.Called(ctx, groupID)

	if len(ret) == 0 {
		panic("no return value specified for CountByGroup")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (int64, error)); ok {
		return returnFunc(ctx, groupID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) int64); ok {
		r0 = returnFunc(ctx, groupID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, groupID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceRepository_CountByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByGroup'
type MockServiceRepository_CountByGroup_Call struct {
	*mock.Call
}

// CountByGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID properties.UUID
func (_e *MockServiceRepository_Expecter) CountByGroup(ctx interface{}, groupID interface{}) *MockServiceRepository_CountByGroup_Call {
	return &MockServiceRepository_CountByGroup_Call{Call: _e.mock.On("CountByGroup", ctx, groupID)}
}

func (_c *MockServiceRepository_CountByGroup_Call) Run(run func(ctx context.Context, groupID properties.UUID)) *MockServiceRepository_CountByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceRepository_CountByGroup_Call) Return(n int64, err error) *MockServiceRepository_CountByGroup_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceRepository_CountByGroup_Call) RunAndReturn(run func(ctx context.Context, groupID properties.UUID) (int64, error)) *MockServiceRepository_CountByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) Create(ctx context.Context, entity *Service) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Service) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockServiceRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Service
func (_e *MockServiceRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockServiceRepository_Create_Call {
	return &MockServiceRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockServiceRepository_Create_Call) Run(run func(ctx context.Context, entity *Service)) *MockServiceRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Service
		if args[1] != nil {
			arg1 = args[1].(*Service)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceRepository_Create_Call) Return(err error) *MockServiceRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *Service) error) *MockServiceRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockServiceRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockServiceRepository_Delete_Call {
	return &MockServiceRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockServiceRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceRepository_Delete_Call) Return(err error) *MockServiceRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockServiceRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockServiceRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockServiceRepository_Exists_Call {
	return &MockServiceRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockServiceRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceRepository_Exists_Call) Return(b bool, err error) *MockServiceRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockServiceRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockServiceRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FindByExternalID provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) FindByExternalID(ctx context.Context, agentID properties.UUID, externalID string) (*Service, error) {
	ret := _mock.Called(ctx, agentID, externalID)

	if len(ret) == 0 {
		panic("no return value specified for FindByExternalID")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, string) (*Service, error)); ok {
		return returnFunc(ctx, agentID, externalID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, string) *Service); ok {
		r0 = returnFunc(ctx, agentID, externalID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, string) error); ok {
		r1 = returnFunc(ctx, agentID, externalID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceRepository_FindByExternalID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByExternalID'
type MockServiceRepository_FindByExternalID_Call struct {
	*mock.Call
}

// FindByExternalID is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID properties.UUID
//   - externalID string
func (_e *MockServiceRepository_Expecter) FindByExternalID(ctx interface{}, agentID interface{}, externalID interface{}) *MockServiceRepository_FindByExternalID_Call {
	return &MockServiceRepository_FindByExternalID_Call{Call: _e.mock.On("FindByExternalID", ctx, agentID, externalID)}
}

func (_c *MockServiceRepository_FindByExternalID_Call) Run(run func(ctx context.Context, agentID properties.UUID, externalID string)) *MockServiceRepository_FindByExternalID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceRepository_FindByExternalID_Call) Return(service *Service, err error) *MockServiceRepository_FindByExternalID_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceRepository_FindByExternalID_Call) RunAndReturn(run func(ctx context.Context, agentID properties.UUID, externalID string) (*Service, error)) *MockServiceRepository_FindByExternalID_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) Get(ctx context.Context, id properties.UUID) (*Service, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Service, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Service); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockServiceRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceRepository_Expecter) Get(ctx interface{}, id interface{}) *MockServiceRepository_Get_Call {
	return &MockServiceRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockServiceRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceRepository_Get_Call) Return(service *Service, err error) *MockServiceRepository_Get_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Service, error)) *MockServiceRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Service], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Service]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Service], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Service]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Service])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockServiceRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockServiceRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockServiceRepository_List_Call {
	return &MockServiceRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockServiceRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockServiceRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceRepository_List_Call) Return(pageRes *PageRes[Service], err error) *MockServiceRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockServiceRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Service], error)) *MockServiceRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockServiceRepository
func (_mock *MockServiceRepository) Save(ctx context.Context, entity *Service) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Service) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockServiceRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Service
func (_e *MockServiceRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockServiceRepository_Save_Call {
	return &MockServiceRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockServiceRepository_Save_Call) Run(run func(ctx context.Context, entity *Service)) *MockServiceRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Service
		if args[1] != nil {
			arg1 = args[1].(*Service)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceRepository_Save_Call) Return(err error) *MockServiceRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *Service) error) *MockServiceRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServiceQuerier creates a new instance of MockServiceQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServiceQuerier {
	mock := &MockServiceQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockServiceQuerier is an autogenerated mock type for the ServiceQuerier type
type MockServiceQuerier struct {
	mock.Mock
}

type MockServiceQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServiceQuerier) EXPECT() *MockServiceQuerier_Expecter {
	return &MockServiceQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockServiceQuerier
func (_mock *MockServiceQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockServiceQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockServiceQuerier_AuthScope_Call {
	return &MockServiceQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockServiceQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockServiceQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockServiceQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockServiceQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockServiceQuerier
func (_mock *MockServiceQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockServiceQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockServiceQuerier_Expecter) Count(ctx interface{}) *MockServiceQuerier_Count_Call {
	return &MockServiceQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockServiceQuerier_Count_Call) Run(run func(ctx context.Context)) *MockServiceQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockServiceQuerier_Count_Call) Return(n int64, err error) *MockServiceQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockServiceQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CountByAgent provides a mock function for the type MockServiceQuerier
func (_mock *MockServiceQuerier) CountByAgent(ctx context.Context, agentID properties.UUID) (int64, error) {
	ret := _mock.Called(ctx, agentID)

	if len(ret) == 0 {
		panic("no return value specified for CountByAgent")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (int64, error)); ok {
		return returnFunc(ctx, agentID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) int64); ok {
		r0 = returnFunc(ctx, agentID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, agentID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceQuerier_CountByAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByAgent'
type MockServiceQuerier_CountByAgent_Call struct {
	*mock.Call
}

// CountByAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID properties.UUID
func (_e *MockServiceQuerier_Expecter) CountByAgent(ctx interface{}, agentID interface{}) *MockServiceQuerier_CountByAgent_Call {
	return &MockServiceQuerier_CountByAgent_Call{Call: _e.mock.On("CountByAgent", ctx, agentID)}
}

func (_c *MockServiceQuerier_CountByAgent_Call) Run(run func(ctx context.Context, agentID properties.UUID)) *MockServiceQuerier_CountByAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceQuerier_CountByAgent_Call) Return(n int64, err error) *MockServiceQuerier_CountByAgent_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceQuerier_CountByAgent_Call) RunAndReturn(run func(ctx context.Context, agentID properties.UUID) (int64, error)) *MockServiceQuerier_CountByAgent_Call {
	_c.Call.Return(run)
	return _c
}

// CountByGroup provides a mock function for the type MockServiceQuerier
func (_mock *MockServiceQuerier) CountByGroup(ctx context.Context, groupID properties.UUID) (int64, error) {
	ret := _mock.Called(ctx, groupID)

	if len(ret) == 0 {
		panic("no return value specified for CountByGroup")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (int64, error)); ok {
		return returnFunc(ctx, groupID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) int64); ok {
		r0 = returnFunc(ctx, groupID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, groupID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceQuerier_CountByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByGroup'
type MockServiceQuerier_CountByGroup_Call struct {
	*mock.Call
}

// CountByGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID properties.UUID
func (_e *MockServiceQuerier_Expecter) CountByGroup(ctx interface{}, groupID interface{}) *MockServiceQuerier_CountByGroup_Call {
	return &MockServiceQuerier_CountByGroup_Call{Call: _e.mock.On("CountByGroup", ctx, groupID)}
}

func (_c *MockServiceQuerier_CountByGroup_Call) Run(run func(ctx context.Context, groupID properties.UUID)) *MockServiceQuerier_CountByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceQuerier_CountByGroup_Call) Return(n int64, err error) *MockServiceQuerier_CountByGroup_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceQuerier_CountByGroup_Call) RunAndReturn(run func(ctx context.Context, groupID properties.UUID) (int64, error)) *MockServiceQuerier_CountByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockServiceQuerier
func (_mock *MockServiceQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockServiceQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockServiceQuerier_Exists_Call {
	return &MockServiceQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockServiceQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceQuerier_Exists_Call) Return(b bool, err error) *MockServiceQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockServiceQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockServiceQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FindByExternalID provides a mock function for the type MockServiceQuerier
func (_mock *MockServiceQuerier) FindByExternalID(ctx context.Context, agentID properties.UUID, externalID string) (*Service, error) {
	ret := _mock.Called(ctx, agentID, externalID)

	if len(ret) == 0 {
		panic("no return value specified for FindByExternalID")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, string) (*Service, error)); ok {
		return returnFunc(ctx, agentID, externalID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, string) *Service); ok {
		r0 = returnFunc(ctx, agentID, externalID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, string) error); ok {
		r1 = returnFunc(ctx, agentID, externalID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceQuerier_FindByExternalID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByExternalID'
type MockServiceQuerier_FindByExternalID_Call struct {
	*mock.Call
}

// FindByExternalID is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID properties.UUID
//   - externalID string
func (_e *MockServiceQuerier_Expecter) FindByExternalID(ctx interface{}, agentID interface{}, externalID interface{}) *MockServiceQuerier_FindByExternalID_Call {
	return &MockServiceQuerier_FindByExternalID_Call{Call: _e.mock.On("FindByExternalID", ctx, agentID, externalID)}
}

func (_c *MockServiceQuerier_FindByExternalID_Call) Run(run func(ctx context.Context, agentID properties.UUID, externalID string)) *MockServiceQuerier_FindByExternalID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceQuerier_FindByExternalID_Call) Return(service *Service, err error) *MockServiceQuerier_FindByExternalID_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceQuerier_FindByExternalID_Call) RunAndReturn(run func(ctx context.Context, agentID properties.UUID, externalID string) (*Service, error)) *MockServiceQuerier_FindByExternalID_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockServiceQuerier
func (_mock *MockServiceQuerier) Get(ctx context.Context, id properties.UUID) (*Service, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Service
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Service, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Service); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Service)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockServiceQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockServiceQuerier_Get_Call {
	return &MockServiceQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockServiceQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceQuerier_Get_Call) Return(service *Service, err error) *MockServiceQuerier_Get_Call {
	_c.Call.Return(service, err)
	return _c
}

func (_c *MockServiceQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Service, error)) *MockServiceQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockServiceQuerier
func (_mock *MockServiceQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Service], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Service]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Service], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Service]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Service])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockServiceQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockServiceQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockServiceQuerier_List_Call {
	return &MockServiceQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockServiceQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockServiceQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceQuerier_List_Call) Return(pageRes *PageRes[Service], err error) *MockServiceQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockServiceQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Service], error)) *MockServiceQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServiceGroupCommander creates a new instance of MockServiceGroupCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceGroupCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServiceGroupCommander {
	mock := &MockServiceGroupCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockServiceGroupCommander is an autogenerated mock type for the ServiceGroupCommander type
type MockServiceGroupCommander struct {
	mock.Mock
}

type MockServiceGroupCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServiceGroupCommander) EXPECT() *MockServiceGroupCommander_Expecter {
	return &MockServiceGroupCommander_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockServiceGroupCommander
func (_mock *MockServiceGroupCommander) Create(ctx context.Context, name string, consumerID properties.UUID) (*ServiceGroup, error) {
	ret := _mock.Called(ctx, name, consumerID)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *ServiceGroup
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, properties.UUID) (*ServiceGroup, error)); ok {
		return returnFunc(ctx, name, consumerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, properties.UUID) *ServiceGroup); ok {
		r0 = returnFunc(ctx, name, consumerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceGroup)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, properties.UUID) error); ok {
		r1 = returnFunc(ctx, name, consumerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupCommander_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockServiceGroupCommander_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - consumerID properties.UUID
func (_e *MockServiceGroupCommander_Expecter) Create(ctx interface{}, name interface{}, consumerID interface{}) *MockServiceGroupCommander_Create_Call {
	return &MockServiceGroupCommander_Create_Call{Call: _e.mock.On("Create", ctx, name, consumerID)}
}

func (_c *MockServiceGroupCommander_Create_Call) Run(run func(ctx context.Context, name string, consumerID properties.UUID)) *MockServiceGroupCommander_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 properties.UUID
		if args[2] != nil {
			arg2 = args[2].(properties.UUID)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceGroupCommander_Create_Call) Return(serviceGroup *ServiceGroup, err error) *MockServiceGroupCommander_Create_Call {
	_c.Call.Return(serviceGroup, err)
	return _c
}

func (_c *MockServiceGroupCommander_Create_Call) RunAndReturn(run func(ctx context.Context, name string, consumerID properties.UUID) (*ServiceGroup, error)) *MockServiceGroupCommander_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockServiceGroupCommander
func (_mock *MockServiceGroupCommander) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceGroupCommander_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockServiceGroupCommander_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceGroupCommander_Expecter) Delete(ctx interface{}, id interface{}) *MockServiceGroupCommander_Delete_Call {
	return &MockServiceGroupCommander_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockServiceGroupCommander_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceGroupCommander_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupCommander_Delete_Call) Return(err error) *MockServiceGroupCommander_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceGroupCommander_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockServiceGroupCommander_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockServiceGroupCommander
func (_mock *MockServiceGroupCommander) Update(ctx context.Context, id properties.UUID, name *string) (*ServiceGroup, error) {
	ret := _mock.Called(ctx, id, name)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *ServiceGroup
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string) (*ServiceGroup, error)); ok {
		return returnFunc(ctx, id, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string) *ServiceGroup); ok {
		r0 = returnFunc(ctx, id, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceGroup)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, *string) error); ok {
		r1 = returnFunc(ctx, id, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupCommander_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockServiceGroupCommander_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
//   - name *string
func (_e *MockServiceGroupCommander_Expecter) Update(ctx interface{}, id interface{}, name interface{}) *MockServiceGroupCommander_Update_Call {
	return &MockServiceGroupCommander_Update_Call{Call: _e.mock.On("Update", ctx, id, name)}
}

func (_c *MockServiceGroupCommander_Update_Call) Run(run func(ctx context.Context, id properties.UUID, name *string)) *MockServiceGroupCommander_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceGroupCommander_Update_Call) Return(serviceGroup *ServiceGroup, err error) *MockServiceGroupCommander_Update_Call {
	_c.Call.Return(serviceGroup, err)
	return _c
}

func (_c *MockServiceGroupCommander_Update_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID, name *string) (*ServiceGroup, error)) *MockServiceGroupCommander_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServiceGroupRepository creates a new instance of MockServiceGroupRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceGroupRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServiceGroupRepository {
	mock := &MockServiceGroupRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockServiceGroupRepository is an autogenerated mock type for the ServiceGroupRepository type
type MockServiceGroupRepository struct {
	mock.Mock
}

type MockServiceGroupRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServiceGroupRepository) EXPECT() *MockServiceGroupRepository_Expecter {
	return &MockServiceGroupRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockServiceGroupRepository
func (_mock *MockServiceGroupRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockServiceGroupRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceGroupRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockServiceGroupRepository_AuthScope_Call {
	return &MockServiceGroupRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockServiceGroupRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceGroupRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockServiceGroupRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockServiceGroupRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockServiceGroupRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockServiceGroupRepository
func (_mock *MockServiceGroupRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockServiceGroupRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockServiceGroupRepository_Expecter) Count(ctx interface{}) *MockServiceGroupRepository_Count_Call {
	return &MockServiceGroupRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockServiceGroupRepository_Count_Call) Run(run func(ctx context.Context)) *MockServiceGroupRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockServiceGroupRepository_Count_Call) Return(n int64, err error) *MockServiceGroupRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceGroupRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockServiceGroupRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockServiceGroupRepository
func (_mock *MockServiceGroupRepository) Create(ctx context.Context, entity *ServiceGroup) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ServiceGroup) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceGroupRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockServiceGroupRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *ServiceGroup
func (_e *MockServiceGroupRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockServiceGroupRepository_Create_Call {
	return &MockServiceGroupRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockServiceGroupRepository_Create_Call) Run(run func(ctx context.Context, entity *ServiceGroup)) *MockServiceGroupRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *ServiceGroup
		if args[1] != nil {
			arg1 = args[1].(*ServiceGroup)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupRepository_Create_Call) Return(err error) *MockServiceGroupRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceGroupRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *ServiceGroup) error) *MockServiceGroupRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockServiceGroupRepository
func (_mock *MockServiceGroupRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceGroupRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockServiceGroupRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceGroupRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockServiceGroupRepository_Delete_Call {
	return &MockServiceGroupRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockServiceGroupRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceGroupRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupRepository_Delete_Call) Return(err error) *MockServiceGroupRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceGroupRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockServiceGroupRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockServiceGroupRepository
func (_mock *MockServiceGroupRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockServiceGroupRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceGroupRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockServiceGroupRepository_Exists_Call {
	return &MockServiceGroupRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockServiceGroupRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceGroupRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupRepository_Exists_Call) Return(b bool, err error) *MockServiceGroupRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockServiceGroupRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockServiceGroupRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockServiceGroupRepository
func (_mock *MockServiceGroupRepository) Get(ctx context.Context, id properties.UUID) (*ServiceGroup, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *ServiceGroup
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*ServiceGroup, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *ServiceGroup); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceGroup)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockServiceGroupRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceGroupRepository_Expecter) Get(ctx interface{}, id interface{}) *MockServiceGroupRepository_Get_Call {
	return &MockServiceGroupRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockServiceGroupRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceGroupRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupRepository_Get_Call) Return(serviceGroup *ServiceGroup, err error) *MockServiceGroupRepository_Get_Call {
	_c.Call.Return(serviceGroup, err)
	return _c
}

func (_c *MockServiceGroupRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*ServiceGroup, error)) *MockServiceGroupRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockServiceGroupRepository
func (_mock *MockServiceGroupRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[ServiceGroup], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[ServiceGroup]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[ServiceGroup], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[ServiceGroup]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[ServiceGroup])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockServiceGroupRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockServiceGroupRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockServiceGroupRepository_List_Call {
	return &MockServiceGroupRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockServiceGroupRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockServiceGroupRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceGroupRepository_List_Call) Return(pageRes *PageRes[ServiceGroup], err error) *MockServiceGroupRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockServiceGroupRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[ServiceGroup], error)) *MockServiceGroupRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockServiceGroupRepository
func (_mock *MockServiceGroupRepository) Save(ctx context.Context, entity *ServiceGroup) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ServiceGroup) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceGroupRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockServiceGroupRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *ServiceGroup
func (_e *MockServiceGroupRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockServiceGroupRepository_Save_Call {
	return &MockServiceGroupRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockServiceGroupRepository_Save_Call) Run(run func(ctx context.Context, entity *ServiceGroup)) *MockServiceGroupRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *ServiceGroup
		if args[1] != nil {
			arg1 = args[1].(*ServiceGroup)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupRepository_Save_Call) Return(err error) *MockServiceGroupRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceGroupRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *ServiceGroup) error) *MockServiceGroupRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServiceGroupQuerier creates a new instance of MockServiceGroupQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceGroupQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServiceGroupQuerier {
	mock := &MockServiceGroupQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockServiceGroupQuerier is an autogenerated mock type for the ServiceGroupQuerier type
type MockServiceGroupQuerier struct {
	mock.Mock
}

type MockServiceGroupQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServiceGroupQuerier) EXPECT() *MockServiceGroupQuerier_Expecter {
	return &MockServiceGroupQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockServiceGroupQuerier
func (_mock *MockServiceGroupQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockServiceGroupQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceGroupQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockServiceGroupQuerier_AuthScope_Call {
	return &MockServiceGroupQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockServiceGroupQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceGroupQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockServiceGroupQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockServiceGroupQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockServiceGroupQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockServiceGroupQuerier
func (_mock *MockServiceGroupQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockServiceGroupQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockServiceGroupQuerier_Expecter) Count(ctx interface{}) *MockServiceGroupQuerier_Count_Call {
	return &MockServiceGroupQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockServiceGroupQuerier_Count_Call) Run(run func(ctx context.Context)) *MockServiceGroupQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockServiceGroupQuerier_Count_Call) Return(n int64, err error) *MockServiceGroupQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceGroupQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockServiceGroupQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockServiceGroupQuerier
func (_mock *MockServiceGroupQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockServiceGroupQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceGroupQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockServiceGroupQuerier_Exists_Call {
	return &MockServiceGroupQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockServiceGroupQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceGroupQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupQuerier_Exists_Call) Return(b bool, err error) *MockServiceGroupQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockServiceGroupQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockServiceGroupQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockServiceGroupQuerier
func (_mock *MockServiceGroupQuerier) Get(ctx context.Context, id properties.UUID) (*ServiceGroup, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *ServiceGroup
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*ServiceGroup, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *ServiceGroup); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceGroup)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockServiceGroupQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceGroupQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockServiceGroupQuerier_Get_Call {
	return &MockServiceGroupQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockServiceGroupQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceGroupQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceGroupQuerier_Get_Call) Return(serviceGroup *ServiceGroup, err error) *MockServiceGroupQuerier_Get_Call {
	_c.Call.Return(serviceGroup, err)
	return _c
}

func (_c *MockServiceGroupQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*ServiceGroup, error)) *MockServiceGroupQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockServiceGroupQuerier
func (_mock *MockServiceGroupQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[ServiceGroup], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[ServiceGroup]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[ServiceGroup], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[ServiceGroup]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[ServiceGroup])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceGroupQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockServiceGroupQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockServiceGroupQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockServiceGroupQuerier_List_Call {
	return &MockServiceGroupQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockServiceGroupQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockServiceGroupQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceGroupQuerier_List_Call) Return(pageRes *PageRes[ServiceGroup], err error) *MockServiceGroupQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockServiceGroupQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[ServiceGroup], error)) *MockServiceGroupQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServiceTypeRepository creates a new instance of MockServiceTypeRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceTypeRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServiceTypeRepository {
	mock := &MockServiceTypeRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockServiceTypeRepository is an autogenerated mock type for the ServiceTypeRepository type
type MockServiceTypeRepository struct {
	mock.Mock
}

type MockServiceTypeRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServiceTypeRepository) EXPECT() *MockServiceTypeRepository_Expecter {
	return &MockServiceTypeRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockServiceTypeRepository
func (_mock *MockServiceTypeRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockServiceTypeRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceTypeRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockServiceTypeRepository_AuthScope_Call {
	return &MockServiceTypeRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockServiceTypeRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceTypeRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockServiceTypeRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockServiceTypeRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockServiceTypeRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockServiceTypeRepository
func (_mock *MockServiceTypeRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockServiceTypeRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockServiceTypeRepository_Expecter) Count(ctx interface{}) *MockServiceTypeRepository_Count_Call {
	return &MockServiceTypeRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockServiceTypeRepository_Count_Call) Run(run func(ctx context.Context)) *MockServiceTypeRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockServiceTypeRepository_Count_Call) Return(n int64, err error) *MockServiceTypeRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceTypeRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockServiceTypeRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockServiceTypeRepository
func (_mock *MockServiceTypeRepository) Create(ctx context.Context, entity *ServiceType) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ServiceType) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceTypeRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockServiceTypeRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *ServiceType
func (_e *MockServiceTypeRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockServiceTypeRepository_Create_Call {
	return &MockServiceTypeRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockServiceTypeRepository_Create_Call) Run(run func(ctx context.Context, entity *ServiceType)) *MockServiceTypeRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *ServiceType
		if args[1] != nil {
			arg1 = args[1].(*ServiceType)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeRepository_Create_Call) Return(err error) *MockServiceTypeRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceTypeRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *ServiceType) error) *MockServiceTypeRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockServiceTypeRepository
func (_mock *MockServiceTypeRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceTypeRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockServiceTypeRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceTypeRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockServiceTypeRepository_Delete_Call {
	return &MockServiceTypeRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockServiceTypeRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceTypeRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeRepository_Delete_Call) Return(err error) *MockServiceTypeRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceTypeRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockServiceTypeRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockServiceTypeRepository
func (_mock *MockServiceTypeRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockServiceTypeRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceTypeRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockServiceTypeRepository_Exists_Call {
	return &MockServiceTypeRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockServiceTypeRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceTypeRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeRepository_Exists_Call) Return(b bool, err error) *MockServiceTypeRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockServiceTypeRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockServiceTypeRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockServiceTypeRepository
func (_mock *MockServiceTypeRepository) Get(ctx context.Context, id properties.UUID) (*ServiceType, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *ServiceType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*ServiceType, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *ServiceType); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockServiceTypeRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceTypeRepository_Expecter) Get(ctx interface{}, id interface{}) *MockServiceTypeRepository_Get_Call {
	return &MockServiceTypeRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockServiceTypeRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceTypeRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeRepository_Get_Call) Return(serviceType *ServiceType, err error) *MockServiceTypeRepository_Get_Call {
	_c.Call.Return(serviceType, err)
	return _c
}

func (_c *MockServiceTypeRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*ServiceType, error)) *MockServiceTypeRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockServiceTypeRepository
func (_mock *MockServiceTypeRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[ServiceType], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[ServiceType]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[ServiceType], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[ServiceType]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[ServiceType])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockServiceTypeRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockServiceTypeRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockServiceTypeRepository_List_Call {
	return &MockServiceTypeRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockServiceTypeRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockServiceTypeRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceTypeRepository_List_Call) Return(pageRes *PageRes[ServiceType], err error) *MockServiceTypeRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockServiceTypeRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[ServiceType], error)) *MockServiceTypeRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockServiceTypeRepository
func (_mock *MockServiceTypeRepository) Save(ctx context.Context, entity *ServiceType) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ServiceType) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockServiceTypeRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockServiceTypeRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *ServiceType
func (_e *MockServiceTypeRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockServiceTypeRepository_Save_Call {
	return &MockServiceTypeRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockServiceTypeRepository_Save_Call) Run(run func(ctx context.Context, entity *ServiceType)) *MockServiceTypeRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *ServiceType
		if args[1] != nil {
			arg1 = args[1].(*ServiceType)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeRepository_Save_Call) Return(err error) *MockServiceTypeRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockServiceTypeRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *ServiceType) error) *MockServiceTypeRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServiceTypeQuerier creates a new instance of MockServiceTypeQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceTypeQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServiceTypeQuerier {
	mock := &MockServiceTypeQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockServiceTypeQuerier is an autogenerated mock type for the ServiceTypeQuerier type
type MockServiceTypeQuerier struct {
	mock.Mock
}

type MockServiceTypeQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServiceTypeQuerier) EXPECT() *MockServiceTypeQuerier_Expecter {
	return &MockServiceTypeQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockServiceTypeQuerier
func (_mock *MockServiceTypeQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockServiceTypeQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceTypeQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockServiceTypeQuerier_AuthScope_Call {
	return &MockServiceTypeQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockServiceTypeQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceTypeQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockServiceTypeQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockServiceTypeQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockServiceTypeQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockServiceTypeQuerier
func (_mock *MockServiceTypeQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockServiceTypeQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockServiceTypeQuerier_Expecter) Count(ctx interface{}) *MockServiceTypeQuerier_Count_Call {
	return &MockServiceTypeQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockServiceTypeQuerier_Count_Call) Run(run func(ctx context.Context)) *MockServiceTypeQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockServiceTypeQuerier_Count_Call) Return(n int64, err error) *MockServiceTypeQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockServiceTypeQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockServiceTypeQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockServiceTypeQuerier
func (_mock *MockServiceTypeQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockServiceTypeQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceTypeQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockServiceTypeQuerier_Exists_Call {
	return &MockServiceTypeQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockServiceTypeQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceTypeQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeQuerier_Exists_Call) Return(b bool, err error) *MockServiceTypeQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockServiceTypeQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockServiceTypeQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockServiceTypeQuerier
func (_mock *MockServiceTypeQuerier) Get(ctx context.Context, id properties.UUID) (*ServiceType, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *ServiceType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*ServiceType, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *ServiceType); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockServiceTypeQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockServiceTypeQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockServiceTypeQuerier_Get_Call {
	return &MockServiceTypeQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockServiceTypeQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockServiceTypeQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockServiceTypeQuerier_Get_Call) Return(serviceType *ServiceType, err error) *MockServiceTypeQuerier_Get_Call {
	_c.Call.Return(serviceType, err)
	return _c
}

func (_c *MockServiceTypeQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*ServiceType, error)) *MockServiceTypeQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockServiceTypeQuerier
func (_mock *MockServiceTypeQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[ServiceType], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[ServiceType]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[ServiceType], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[ServiceType]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[ServiceType])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockServiceTypeQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockServiceTypeQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockServiceTypeQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockServiceTypeQuerier_List_Call {
	return &MockServiceTypeQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockServiceTypeQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockServiceTypeQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockServiceTypeQuerier_List_Call) Return(pageRes *PageRes[ServiceType], err error) *MockServiceTypeQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockServiceTypeQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[ServiceType], error)) *MockServiceTypeQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// AgentRepo provides a mock function for the type MockStore
func (_mock *MockStore) AgentRepo() AgentRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for AgentRepo")
	}

	var r0 AgentRepository
	if returnFunc, ok := ret.Get(0).(func() AgentRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(AgentRepository)
		}
	}
	return r0
}

// MockStore_AgentRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentRepo'
type MockStore_AgentRepo_Call struct {
	*mock.Call
}

// AgentRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) AgentRepo() *MockStore_AgentRepo_Call {
	return &MockStore_AgentRepo_Call{Call: _e.mock.On("AgentRepo")}
}

func (_c *MockStore_AgentRepo_Call) Run(run func()) *MockStore_AgentRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_AgentRepo_Call) Return(agentRepository AgentRepository) *MockStore_AgentRepo_Call {
	_c.Call.Return(agentRepository)
	return _c
}

func (_c *MockStore_AgentRepo_Call) RunAndReturn(run func() AgentRepository) *MockStore_AgentRepo_Call {
	_c.Call.Return(run)
	return _c
}

// AgentTypeRepo provides a mock function for the type MockStore
func (_mock *MockStore) AgentTypeRepo() AgentTypeRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for AgentTypeRepo")
	}

	var r0 AgentTypeRepository
	if returnFunc, ok := ret.Get(0).(func() AgentTypeRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(AgentTypeRepository)
		}
	}
	return r0
}

// MockStore_AgentTypeRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentTypeRepo'
type MockStore_AgentTypeRepo_Call struct {
	*mock.Call
}

// AgentTypeRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) AgentTypeRepo() *MockStore_AgentTypeRepo_Call {
	return &MockStore_AgentTypeRepo_Call{Call: _e.mock.On("AgentTypeRepo")}
}

func (_c *MockStore_AgentTypeRepo_Call) Run(run func()) *MockStore_AgentTypeRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_AgentTypeRepo_Call) Return(agentTypeRepository AgentTypeRepository) *MockStore_AgentTypeRepo_Call {
	_c.Call.Return(agentTypeRepository)
	return _c
}

func (_c *MockStore_AgentTypeRepo_Call) RunAndReturn(run func() AgentTypeRepository) *MockStore_AgentTypeRepo_Call {
	_c.Call.Return(run)
	return _c
}

// Atomic provides a mock function for the type MockStore
func (_mock *MockStore) Atomic(context1 context.Context, fn func(Store) error) error {
	ret := _mock.Called(context1, fn)

	if len(ret) == 0 {
		panic("no return value specified for Atomic")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(Store) error) error); ok {
		r0 = returnFunc(context1, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_Atomic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Atomic'
type MockStore_Atomic_Call struct {
	*mock.Call
}

// Atomic is a helper method to define mock.On call
//   - context1 context.Context
//   - fn func(Store) error
func (_e *MockStore_Expecter) Atomic(context1 interface{}, fn interface{}) *MockStore_Atomic_Call {
	return &MockStore_Atomic_Call{Call: _e.mock.On("Atomic", context1, fn)}
}

func (_c *MockStore_Atomic_Call) Run(run func(context1 context.Context, fn func(Store) error)) *MockStore_Atomic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(Store) error
		if args[1] != nil {
			arg1 = args[1].(func(Store) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_Atomic_Call) Return(err error) *MockStore_Atomic_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_Atomic_Call) RunAndReturn(run func(context1 context.Context, fn func(Store) error) error) *MockStore_Atomic_Call {
	_c.Call.Return(run)
	return _c
}

// EventRepo provides a mock function for the type MockStore
func (_mock *MockStore) EventRepo() EventRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EventRepo")
	}

	var r0 EventRepository
	if returnFunc, ok := ret.Get(0).(func() EventRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(EventRepository)
		}
	}
	return r0
}

// MockStore_EventRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EventRepo'
type MockStore_EventRepo_Call struct {
	*mock.Call
}

// EventRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) EventRepo() *MockStore_EventRepo_Call {
	return &MockStore_EventRepo_Call{Call: _e.mock.On("EventRepo")}
}

func (_c *MockStore_EventRepo_Call) Run(run func()) *MockStore_EventRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_EventRepo_Call) Return(eventRepository EventRepository) *MockStore_EventRepo_Call {
	_c.Call.Return(eventRepository)
	return _c
}

func (_c *MockStore_EventRepo_Call) RunAndReturn(run func() EventRepository) *MockStore_EventRepo_Call {
	_c.Call.Return(run)
	return _c
}

// EventSubscriptionRepo provides a mock function for the type MockStore
func (_mock *MockStore) EventSubscriptionRepo() EventSubscriptionRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EventSubscriptionRepo")
	}

	var r0 EventSubscriptionRepository
	if returnFunc, ok := ret.Get(0).(func() EventSubscriptionRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(EventSubscriptionRepository)
		}
	}
	return r0
}

// MockStore_EventSubscriptionRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EventSubscriptionRepo'
type MockStore_EventSubscriptionRepo_Call struct {
	*mock.Call
}

// EventSubscriptionRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) EventSubscriptionRepo() *MockStore_EventSubscriptionRepo_Call {
	return &MockStore_EventSubscriptionRepo_Call{Call: _e.mock.On("EventSubscriptionRepo")}
}

func (_c *MockStore_EventSubscriptionRepo_Call) Run(run func()) *MockStore_EventSubscriptionRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_EventSubscriptionRepo_Call) Return(eventSubscriptionRepository EventSubscriptionRepository) *MockStore_EventSubscriptionRepo_Call {
	_c.Call.Return(eventSubscriptionRepository)
	return _c
}

func (_c *MockStore_EventSubscriptionRepo_Call) RunAndReturn(run func() EventSubscriptionRepository) *MockStore_EventSubscriptionRepo_Call {
	_c.Call.Return(run)
	return _c
}

// JobRepo provides a mock function for the type MockStore
func (_mock *MockStore) JobRepo() JobRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for JobRepo")
	}

	var r0 JobRepository
	if returnFunc, ok := ret.Get(0).(func() JobRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(JobRepository)
		}
	}
	return r0
}

// MockStore_JobRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JobRepo'
type MockStore_JobRepo_Call struct {
	*mock.Call
}

// JobRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) JobRepo() *MockStore_JobRepo_Call {
	return &MockStore_JobRepo_Call{Call: _e.mock.On("JobRepo")}
}

func (_c *MockStore_JobRepo_Call) Run(run func()) *MockStore_JobRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_JobRepo_Call) Return(jobRepository JobRepository) *MockStore_JobRepo_Call {
	_c.Call.Return(jobRepository)
	return _c
}

func (_c *MockStore_JobRepo_Call) RunAndReturn(run func() JobRepository) *MockStore_JobRepo_Call {
	_c.Call.Return(run)
	return _c
}

// MetricEntryRepo provides a mock function for the type MockStore
func (_mock *MockStore) MetricEntryRepo() MetricEntryRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MetricEntryRepo")
	}

	var r0 MetricEntryRepository
	if returnFunc, ok := ret.Get(0).(func() MetricEntryRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(MetricEntryRepository)
		}
	}
	return r0
}

// MockStore_MetricEntryRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetricEntryRepo'
type MockStore_MetricEntryRepo_Call struct {
	*mock.Call
}

// MetricEntryRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) MetricEntryRepo() *MockStore_MetricEntryRepo_Call {
	return &MockStore_MetricEntryRepo_Call{Call: _e.mock.On("MetricEntryRepo")}
}

func (_c *MockStore_MetricEntryRepo_Call) Run(run func()) *MockStore_MetricEntryRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_MetricEntryRepo_Call) Return(metricEntryRepository MetricEntryRepository) *MockStore_MetricEntryRepo_Call {
	_c.Call.Return(metricEntryRepository)
	return _c
}

func (_c *MockStore_MetricEntryRepo_Call) RunAndReturn(run func() MetricEntryRepository) *MockStore_MetricEntryRepo_Call {
	_c.Call.Return(run)
	return _c
}

// MetricTypeRepo provides a mock function for the type MockStore
func (_mock *MockStore) MetricTypeRepo() MetricTypeRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MetricTypeRepo")
	}

	var r0 MetricTypeRepository
	if returnFunc, ok := ret.Get(0).(func() MetricTypeRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(MetricTypeRepository)
		}
	}
	return r0
}

// MockStore_MetricTypeRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetricTypeRepo'
type MockStore_MetricTypeRepo_Call struct {
	*mock.Call
}

// MetricTypeRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) MetricTypeRepo() *MockStore_MetricTypeRepo_Call {
	return &MockStore_MetricTypeRepo_Call{Call: _e.mock.On("MetricTypeRepo")}
}

func (_c *MockStore_MetricTypeRepo_Call) Run(run func()) *MockStore_MetricTypeRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_MetricTypeRepo_Call) Return(metricTypeRepository MetricTypeRepository) *MockStore_MetricTypeRepo_Call {
	_c.Call.Return(metricTypeRepository)
	return _c
}

func (_c *MockStore_MetricTypeRepo_Call) RunAndReturn(run func() MetricTypeRepository) *MockStore_MetricTypeRepo_Call {
	_c.Call.Return(run)
	return _c
}

// ParticipantRepo provides a mock function for the type MockStore
func (_mock *MockStore) ParticipantRepo() ParticipantRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ParticipantRepo")
	}

	var r0 ParticipantRepository
	if returnFunc, ok := ret.Get(0).(func() ParticipantRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ParticipantRepository)
		}
	}
	return r0
}

// MockStore_ParticipantRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParticipantRepo'
type MockStore_ParticipantRepo_Call struct {
	*mock.Call
}

// ParticipantRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) ParticipantRepo() *MockStore_ParticipantRepo_Call {
	return &MockStore_ParticipantRepo_Call{Call: _e.mock.On("ParticipantRepo")}
}

func (_c *MockStore_ParticipantRepo_Call) Run(run func()) *MockStore_ParticipantRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_ParticipantRepo_Call) Return(participantRepository ParticipantRepository) *MockStore_ParticipantRepo_Call {
	_c.Call.Return(participantRepository)
	return _c
}

func (_c *MockStore_ParticipantRepo_Call) RunAndReturn(run func() ParticipantRepository) *MockStore_ParticipantRepo_Call {
	_c.Call.Return(run)
	return _c
}

// ServiceGroupRepo provides a mock function for the type MockStore
func (_mock *MockStore) ServiceGroupRepo() ServiceGroupRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ServiceGroupRepo")
	}

	var r0 ServiceGroupRepository
	if returnFunc, ok := ret.Get(0).(func() ServiceGroupRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ServiceGroupRepository)
		}
	}
	return r0
}

// MockStore_ServiceGroupRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceGroupRepo'
type MockStore_ServiceGroupRepo_Call struct {
	*mock.Call
}

// ServiceGroupRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) ServiceGroupRepo() *MockStore_ServiceGroupRepo_Call {
	return &MockStore_ServiceGroupRepo_Call{Call: _e.mock.On("ServiceGroupRepo")}
}

func (_c *MockStore_ServiceGroupRepo_Call) Run(run func()) *MockStore_ServiceGroupRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_ServiceGroupRepo_Call) Return(serviceGroupRepository ServiceGroupRepository) *MockStore_ServiceGroupRepo_Call {
	_c.Call.Return(serviceGroupRepository)
	return _c
}

func (_c *MockStore_ServiceGroupRepo_Call) RunAndReturn(run func() ServiceGroupRepository) *MockStore_ServiceGroupRepo_Call {
	_c.Call.Return(run)
	return _c
}

// ServiceRepo provides a mock function for the type MockStore
func (_mock *MockStore) ServiceRepo() ServiceRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ServiceRepo")
	}

	var r0 ServiceRepository
	if returnFunc, ok := ret.Get(0).(func() ServiceRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ServiceRepository)
		}
	}
	return r0
}

// MockStore_ServiceRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceRepo'
type MockStore_ServiceRepo_Call struct {
	*mock.Call
}

// ServiceRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) ServiceRepo() *MockStore_ServiceRepo_Call {
	return &MockStore_ServiceRepo_Call{Call: _e.mock.On("ServiceRepo")}
}

func (_c *MockStore_ServiceRepo_Call) Run(run func()) *MockStore_ServiceRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_ServiceRepo_Call) Return(serviceRepository ServiceRepository) *MockStore_ServiceRepo_Call {
	_c.Call.Return(serviceRepository)
	return _c
}

func (_c *MockStore_ServiceRepo_Call) RunAndReturn(run func() ServiceRepository) *MockStore_ServiceRepo_Call {
	_c.Call.Return(run)
	return _c
}

// ServiceTypeRepo provides a mock function for the type MockStore
func (_mock *MockStore) ServiceTypeRepo() ServiceTypeRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ServiceTypeRepo")
	}

	var r0 ServiceTypeRepository
	if returnFunc, ok := ret.Get(0).(func() ServiceTypeRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ServiceTypeRepository)
		}
	}
	return r0
}

// MockStore_ServiceTypeRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceTypeRepo'
type MockStore_ServiceTypeRepo_Call struct {
	*mock.Call
}

// ServiceTypeRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) ServiceTypeRepo() *MockStore_ServiceTypeRepo_Call {
	return &MockStore_ServiceTypeRepo_Call{Call: _e.mock.On("ServiceTypeRepo")}
}

func (_c *MockStore_ServiceTypeRepo_Call) Run(run func()) *MockStore_ServiceTypeRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_ServiceTypeRepo_Call) Return(serviceTypeRepository ServiceTypeRepository) *MockStore_ServiceTypeRepo_Call {
	_c.Call.Return(serviceTypeRepository)
	return _c
}

func (_c *MockStore_ServiceTypeRepo_Call) RunAndReturn(run func() ServiceTypeRepository) *MockStore_ServiceTypeRepo_Call {
	_c.Call.Return(run)
	return _c
}

// TokenRepo provides a mock function for the type MockStore
func (_mock *MockStore) TokenRepo() TokenRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TokenRepo")
	}

	var r0 TokenRepository
	if returnFunc, ok := ret.Get(0).(func() TokenRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(TokenRepository)
		}
	}
	return r0
}

// MockStore_TokenRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TokenRepo'
type MockStore_TokenRepo_Call struct {
	*mock.Call
}

// TokenRepo is a helper method to define mock.On call
func (_e *MockStore_Expecter) TokenRepo() *MockStore_TokenRepo_Call {
	return &MockStore_TokenRepo_Call{Call: _e.mock.On("TokenRepo")}
}

func (_c *MockStore_TokenRepo_Call) Run(run func()) *MockStore_TokenRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_TokenRepo_Call) Return(tokenRepository TokenRepository) *MockStore_TokenRepo_Call {
	_c.Call.Return(tokenRepository)
	return _c
}

func (_c *MockStore_TokenRepo_Call) RunAndReturn(run func() TokenRepository) *MockStore_TokenRepo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTokenCommander creates a new instance of MockTokenCommander. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTokenCommander(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTokenCommander {
	mock := &MockTokenCommander{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTokenCommander is an autogenerated mock type for the TokenCommander type
type MockTokenCommander struct {
	mock.Mock
}

type MockTokenCommander_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTokenCommander) EXPECT() *MockTokenCommander_Expecter {
	return &MockTokenCommander_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockTokenCommander
func (_mock *MockTokenCommander) Create(ctx context.Context, name string, role auth.Role, expireAt *time.Time, scopeID *properties.UUID) (*Token, error) {
	ret := _mock.Called(ctx, name, role, expireAt, scopeID)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, auth.Role, *time.Time, *properties.UUID) (*Token, error)); ok {
		return returnFunc(ctx, name, role, expireAt, scopeID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, auth.Role, *time.Time, *properties.UUID) *Token); ok {
		r0 = returnFunc(ctx, name, role, expireAt, scopeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, auth.Role, *time.Time, *properties.UUID) error); ok {
		r1 = returnFunc(ctx, name, role, expireAt, scopeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenCommander_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockTokenCommander_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - role auth.Role
//   - expireAt *time.Time
//   - scopeID *properties.UUID
func (_e *MockTokenCommander_Expecter) Create(ctx interface{}, name interface{}, role interface{}, expireAt interface{}, scopeID interface{}) *MockTokenCommander_Create_Call {
	return &MockTokenCommander_Create_Call{Call: _e.mock.On("Create", ctx, name, role, expireAt, scopeID)}
}

func (_c *MockTokenCommander_Create_Call) Run(run func(ctx context.Context, name string, role auth.Role, expireAt *time.Time, scopeID *properties.UUID)) *MockTokenCommander_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 auth.Role
		if args[2] != nil {
			arg2 = args[2].(auth.Role)
		}
		var arg3 *time.Time
		if args[3] != nil {
			arg3 = args[3].(*time.Time)
		}
		var arg4 *properties.UUID
		if args[4] != nil {
			arg4 = args[4].(*properties.UUID)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockTokenCommander_Create_Call) Return(token *Token, err error) *MockTokenCommander_Create_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenCommander_Create_Call) RunAndReturn(run func(ctx context.Context, name string, role auth.Role, expireAt *time.Time, scopeID *properties.UUID) (*Token, error)) *MockTokenCommander_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockTokenCommander
func (_mock *MockTokenCommander) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTokenCommander_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockTokenCommander_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenCommander_Expecter) Delete(ctx interface{}, id interface{}) *MockTokenCommander_Delete_Call {
	return &MockTokenCommander_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockTokenCommander_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenCommander_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenCommander_Delete_Call) Return(err error) *MockTokenCommander_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTokenCommander_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockTokenCommander_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Regenerate provides a mock function for the type MockTokenCommander
func (_mock *MockTokenCommander) Regenerate(ctx context.Context, id properties.UUID) (*Token, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Regenerate")
	}

	var r0 *Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Token, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Token); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenCommander_Regenerate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Regenerate'
type MockTokenCommander_Regenerate_Call struct {
	*mock.Call
}

// Regenerate is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenCommander_Expecter) Regenerate(ctx interface{}, id interface{}) *MockTokenCommander_Regenerate_Call {
	return &MockTokenCommander_Regenerate_Call{Call: _e.mock.On("Regenerate", ctx, id)}
}

func (_c *MockTokenCommander_Regenerate_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenCommander_Regenerate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenCommander_Regenerate_Call) Return(token *Token, err error) *MockTokenCommander_Regenerate_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenCommander_Regenerate_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Token, error)) *MockTokenCommander_Regenerate_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockTokenCommander
func (_mock *MockTokenCommander) Update(ctx context.Context, id properties.UUID, name *string, expireAt *time.Time) (*Token, error) {
	ret := _mock.Called(ctx, id, name, expireAt)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string, *time.Time) (*Token, error)); ok {
		return returnFunc(ctx, id, name, expireAt)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID, *string, *time.Time) *Token); ok {
		r0 = returnFunc(ctx, id, name, expireAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID, *string, *time.Time) error); ok {
		r1 = returnFunc(ctx, id, name, expireAt)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenCommander_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockTokenCommander_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
//   - name *string
//   - expireAt *time.Time
func (_e *MockTokenCommander_Expecter) Update(ctx interface{}, id interface{}, name interface{}, expireAt interface{}) *MockTokenCommander_Update_Call {
	return &MockTokenCommander_Update_Call{Call: _e.mock.On("Update", ctx, id, name, expireAt)}
}

func (_c *MockTokenCommander_Update_Call) Run(run func(ctx context.Context, id properties.UUID, name *string, expireAt *time.Time)) *MockTokenCommander_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		var arg3 *time.Time
		if args[3] != nil {
			arg3 = args[3].(*time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockTokenCommander_Update_Call) Return(token *Token, err error) *MockTokenCommander_Update_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenCommander_Update_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID, name *string, expireAt *time.Time) (*Token, error)) *MockTokenCommander_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTokenRepository creates a new instance of MockTokenRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTokenRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTokenRepository {
	mock := &MockTokenRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTokenRepository is an autogenerated mock type for the TokenRepository type
type MockTokenRepository struct {
	mock.Mock
}

type MockTokenRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTokenRepository) EXPECT() *MockTokenRepository_Expecter {
	return &MockTokenRepository_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenRepository_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockTokenRepository_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenRepository_Expecter) AuthScope(ctx interface{}, id interface{}) *MockTokenRepository_AuthScope_Call {
	return &MockTokenRepository_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockTokenRepository_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenRepository_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockTokenRepository_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockTokenRepository_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockTokenRepository_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockTokenRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTokenRepository_Expecter) Count(ctx interface{}) *MockTokenRepository_Count_Call {
	return &MockTokenRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockTokenRepository_Count_Call) Run(run func(ctx context.Context)) *MockTokenRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockTokenRepository_Count_Call) Return(n int64, err error) *MockTokenRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockTokenRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockTokenRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) Create(ctx context.Context, entity *Token) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Token) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTokenRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockTokenRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Token
func (_e *MockTokenRepository_Expecter) Create(ctx interface{}, entity interface{}) *MockTokenRepository_Create_Call {
	return &MockTokenRepository_Create_Call{Call: _e.mock.On("Create", ctx, entity)}
}

func (_c *MockTokenRepository_Create_Call) Run(run func(ctx context.Context, entity *Token)) *MockTokenRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Token
		if args[1] != nil {
			arg1 = args[1].(*Token)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_Create_Call) Return(err error) *MockTokenRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTokenRepository_Create_Call) RunAndReturn(run func(ctx context.Context, entity *Token) error) *MockTokenRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) Delete(ctx context.Context, id properties.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTokenRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockTokenRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockTokenRepository_Delete_Call {
	return &MockTokenRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockTokenRepository_Delete_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_Delete_Call) Return(err error) *MockTokenRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTokenRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) error) *MockTokenRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByAgentID provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) DeleteByAgentID(ctx context.Context, agentID properties.UUID) error {
	ret := _mock.Called(ctx, agentID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByAgentID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, agentID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTokenRepository_DeleteByAgentID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByAgentID'
type MockTokenRepository_DeleteByAgentID_Call struct {
	*mock.Call
}

// DeleteByAgentID is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID properties.UUID
func (_e *MockTokenRepository_Expecter) DeleteByAgentID(ctx interface{}, agentID interface{}) *MockTokenRepository_DeleteByAgentID_Call {
	return &MockTokenRepository_DeleteByAgentID_Call{Call: _e.mock.On("DeleteByAgentID", ctx, agentID)}
}

func (_c *MockTokenRepository_DeleteByAgentID_Call) Run(run func(ctx context.Context, agentID properties.UUID)) *MockTokenRepository_DeleteByAgentID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_DeleteByAgentID_Call) Return(err error) *MockTokenRepository_DeleteByAgentID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTokenRepository_DeleteByAgentID_Call) RunAndReturn(run func(ctx context.Context, agentID properties.UUID) error) *MockTokenRepository_DeleteByAgentID_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByParticipantID provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) DeleteByParticipantID(ctx context.Context, participantID properties.UUID) error {
	ret := _mock.Called(ctx, participantID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByParticipantID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) error); ok {
		r0 = returnFunc(ctx, participantID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTokenRepository_DeleteByParticipantID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByParticipantID'
type MockTokenRepository_DeleteByParticipantID_Call struct {
	*mock.Call
}

// DeleteByParticipantID is a helper method to define mock.On call
//   - ctx context.Context
//   - participantID properties.UUID
func (_e *MockTokenRepository_Expecter) DeleteByParticipantID(ctx interface{}, participantID interface{}) *MockTokenRepository_DeleteByParticipantID_Call {
	return &MockTokenRepository_DeleteByParticipantID_Call{Call: _e.mock.On("DeleteByParticipantID", ctx, participantID)}
}

func (_c *MockTokenRepository_DeleteByParticipantID_Call) Run(run func(ctx context.Context, participantID properties.UUID)) *MockTokenRepository_DeleteByParticipantID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_DeleteByParticipantID_Call) Return(err error) *MockTokenRepository_DeleteByParticipantID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTokenRepository_DeleteByParticipantID_Call) RunAndReturn(run func(ctx context.Context, participantID properties.UUID) error) *MockTokenRepository_DeleteByParticipantID_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockTokenRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenRepository_Expecter) Exists(ctx interface{}, id interface{}) *MockTokenRepository_Exists_Call {
	return &MockTokenRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockTokenRepository_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_Exists_Call) Return(b bool, err error) *MockTokenRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockTokenRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockTokenRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FindByHashedValue provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) FindByHashedValue(ctx context.Context, hashedValue string) (*Token, error) {
	ret := _mock.Called(ctx, hashedValue)

	if len(ret) == 0 {
		panic("no return value specified for FindByHashedValue")
	}

	var r0 *Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*Token, error)); ok {
		return returnFunc(ctx, hashedValue)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *Token); ok {
		r0 = returnFunc(ctx, hashedValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, hashedValue)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenRepository_FindByHashedValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByHashedValue'
type MockTokenRepository_FindByHashedValue_Call struct {
	*mock.Call
}

// FindByHashedValue is a helper method to define mock.On call
//   - ctx context.Context
//   - hashedValue string
func (_e *MockTokenRepository_Expecter) FindByHashedValue(ctx interface{}, hashedValue interface{}) *MockTokenRepository_FindByHashedValue_Call {
	return &MockTokenRepository_FindByHashedValue_Call{Call: _e.mock.On("FindByHashedValue", ctx, hashedValue)}
}

func (_c *MockTokenRepository_FindByHashedValue_Call) Run(run func(ctx context.Context, hashedValue string)) *MockTokenRepository_FindByHashedValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_FindByHashedValue_Call) Return(token *Token, err error) *MockTokenRepository_FindByHashedValue_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenRepository_FindByHashedValue_Call) RunAndReturn(run func(ctx context.Context, hashedValue string) (*Token, error)) *MockTokenRepository_FindByHashedValue_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) Get(ctx context.Context, id properties.UUID) (*Token, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Token, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Token); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockTokenRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenRepository_Expecter) Get(ctx interface{}, id interface{}) *MockTokenRepository_Get_Call {
	return &MockTokenRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockTokenRepository_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_Get_Call) Return(token *Token, err error) *MockTokenRepository_Get_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenRepository_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Token, error)) *MockTokenRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Token], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Token]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Token], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Token]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Token])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockTokenRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockTokenRepository_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockTokenRepository_List_Call {
	return &MockTokenRepository_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockTokenRepository_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockTokenRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockTokenRepository_List_Call) Return(pageRes *PageRes[Token], err error) *MockTokenRepository_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockTokenRepository_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Token], error)) *MockTokenRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockTokenRepository
func (_mock *MockTokenRepository) Save(ctx context.Context, entity *Token) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Token) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTokenRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockTokenRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Token
func (_e *MockTokenRepository_Expecter) Save(ctx interface{}, entity interface{}) *MockTokenRepository_Save_Call {
	return &MockTokenRepository_Save_Call{Call: _e.mock.On("Save", ctx, entity)}
}

func (_c *MockTokenRepository_Save_Call) Run(run func(ctx context.Context, entity *Token)) *MockTokenRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Token
		if args[1] != nil {
			arg1 = args[1].(*Token)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenRepository_Save_Call) Return(err error) *MockTokenRepository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTokenRepository_Save_Call) RunAndReturn(run func(ctx context.Context, entity *Token) error) *MockTokenRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTokenQuerier creates a new instance of MockTokenQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTokenQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTokenQuerier {
	mock := &MockTokenQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTokenQuerier is an autogenerated mock type for the TokenQuerier type
type MockTokenQuerier struct {
	mock.Mock
}

type MockTokenQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTokenQuerier) EXPECT() *MockTokenQuerier_Expecter {
	return &MockTokenQuerier_Expecter{mock: &_m.Mock}
}

// AuthScope provides a mock function for the type MockTokenQuerier
func (_mock *MockTokenQuerier) AuthScope(ctx context.Context, id properties.UUID) (auth.ObjectScope, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for AuthScope")
	}

	var r0 auth.ObjectScope
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (auth.ObjectScope, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) auth.ObjectScope); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(auth.ObjectScope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenQuerier_AuthScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScope'
type MockTokenQuerier_AuthScope_Call struct {
	*mock.Call
}

// AuthScope is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenQuerier_Expecter) AuthScope(ctx interface{}, id interface{}) *MockTokenQuerier_AuthScope_Call {
	return &MockTokenQuerier_AuthScope_Call{Call: _e.mock.On("AuthScope", ctx, id)}
}

func (_c *MockTokenQuerier_AuthScope_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenQuerier_AuthScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenQuerier_AuthScope_Call) Return(objectScope auth.ObjectScope, err error) *MockTokenQuerier_AuthScope_Call {
	_c.Call.Return(objectScope, err)
	return _c
}

func (_c *MockTokenQuerier_AuthScope_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (auth.ObjectScope, error)) *MockTokenQuerier_AuthScope_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockTokenQuerier
func (_mock *MockTokenQuerier) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenQuerier_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockTokenQuerier_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTokenQuerier_Expecter) Count(ctx interface{}) *MockTokenQuerier_Count_Call {
	return &MockTokenQuerier_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockTokenQuerier_Count_Call) Run(run func(ctx context.Context)) *MockTokenQuerier_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockTokenQuerier_Count_Call) Return(n int64, err error) *MockTokenQuerier_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockTokenQuerier_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockTokenQuerier_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockTokenQuerier
func (_mock *MockTokenQuerier) Exists(ctx context.Context, id properties.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockTokenQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenQuerier_Expecter) Exists(ctx interface{}, id interface{}) *MockTokenQuerier_Exists_Call {
	return &MockTokenQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, id)}
}

func (_c *MockTokenQuerier_Exists_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenQuerier_Exists_Call) Return(b bool, err error) *MockTokenQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockTokenQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (bool, error)) *MockTokenQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FindByHashedValue provides a mock function for the type MockTokenQuerier
func (_mock *MockTokenQuerier) FindByHashedValue(ctx context.Context, hashedValue string) (*Token, error) {
	ret := _mock.Called(ctx, hashedValue)

	if len(ret) == 0 {
		panic("no return value specified for FindByHashedValue")
	}

	var r0 *Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*Token, error)); ok {
		return returnFunc(ctx, hashedValue)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *Token); ok {
		r0 = returnFunc(ctx, hashedValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, hashedValue)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenQuerier_FindByHashedValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByHashedValue'
type MockTokenQuerier_FindByHashedValue_Call struct {
	*mock.Call
}

// FindByHashedValue is a helper method to define mock.On call
//   - ctx context.Context
//   - hashedValue string
func (_e *MockTokenQuerier_Expecter) FindByHashedValue(ctx interface{}, hashedValue interface{}) *MockTokenQuerier_FindByHashedValue_Call {
	return &MockTokenQuerier_FindByHashedValue_Call{Call: _e.mock.On("FindByHashedValue", ctx, hashedValue)}
}

func (_c *MockTokenQuerier_FindByHashedValue_Call) Run(run func(ctx context.Context, hashedValue string)) *MockTokenQuerier_FindByHashedValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenQuerier_FindByHashedValue_Call) Return(token *Token, err error) *MockTokenQuerier_FindByHashedValue_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenQuerier_FindByHashedValue_Call) RunAndReturn(run func(ctx context.Context, hashedValue string) (*Token, error)) *MockTokenQuerier_FindByHashedValue_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockTokenQuerier
func (_mock *MockTokenQuerier) Get(ctx context.Context, id properties.UUID) (*Token, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) (*Token, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, properties.UUID) *Token); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, properties.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockTokenQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id properties.UUID
func (_e *MockTokenQuerier_Expecter) Get(ctx interface{}, id interface{}) *MockTokenQuerier_Get_Call {
	return &MockTokenQuerier_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockTokenQuerier_Get_Call) Run(run func(ctx context.Context, id properties.UUID)) *MockTokenQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 properties.UUID
		if args[1] != nil {
			arg1 = args[1].(properties.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTokenQuerier_Get_Call) Return(token *Token, err error) *MockTokenQuerier_Get_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, id properties.UUID) (*Token, error)) *MockTokenQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockTokenQuerier
func (_mock *MockTokenQuerier) List(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Token], error) {
	ret := _mock.Called(ctx, scope, req)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *PageRes[Token]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) (*PageRes[Token], error)); ok {
		return returnFunc(ctx, scope, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.IdentityScope, *PageReq) *PageRes[Token]); ok {
		r0 = returnFunc(ctx, scope, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageRes[Token])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.IdentityScope, *PageReq) error); ok {
		r1 = returnFunc(ctx, scope, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenQuerier_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockTokenQuerier_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scope *auth.IdentityScope
//   - req *PageReq
func (_e *MockTokenQuerier_Expecter) List(ctx interface{}, scope interface{}, req interface{}) *MockTokenQuerier_List_Call {
	return &MockTokenQuerier_List_Call{Call: _e.mock.On("List", ctx, scope, req)}
}

func (_c *MockTokenQuerier_List_Call) Run(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq)) *MockTokenQuerier_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.IdentityScope
		if args[1] != nil {
			arg1 = args[1].(*auth.IdentityScope)
		}
		var arg2 *PageReq
		if args[2] != nil {
			arg2 = args[2].(*PageReq)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockTokenQuerier_List_Call) Return(pageRes *PageRes[Token], err error) *MockTokenQuerier_List_Call {
	_c.Call.Return(pageRes, err)
	return _c
}

func (_c *MockTokenQuerier_List_Call) RunAndReturn(run func(ctx context.Context, scope *auth.IdentityScope, req *PageReq) (*PageRes[Token], error)) *MockTokenQuerier_List_Call {
	_c.Call.Return(run)
	return _c
}
